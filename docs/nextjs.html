<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>Next.js</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article">
<div id="header">
<h1>Next.js</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introducción">Introducción</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Next.js es un framework de React para construir aplicaciones web full-stack. Utilizas componentes de React para construir interfaces de usuario y Next.js para características y optimizaciones adicionales.</p>
</div>
<div class="paragraph">
<p>Next.js también abstrae y configura automáticamente las herramientas necesarias para React, como el empaquetado, la compilación y más. Esto le permite concentrarse en la construcción de su aplicación en lugar de pasar tiempo con la configuración.</p>
</div>
<div class="ulist">
<div class="title">Principales características de Next.js</div>
<ul>
<li>
<p><strong>Routing:</strong>	Un enrutador basado en el sistema de archivos construido sobre Componentes del Servidor que admite layouts, enrutamiento anidado, estados de carga, manejo de errores y más.</p>
</li>
<li>
<p><strong>Rendering:</strong>	Renderizado del lado del cliente y del servidor con Componentes del Cliente y del Servidor. Además, optimizado con Renderizado Estático y Dinámico en el servidor con Next.js.</p>
</li>
<li>
<p><strong>Data Fetching:</strong>	Simplificación de la obtención de datos con async/await en Componentes del Servidor, y una API de fetch extendida para la memorización de solicitudes, el almacenamiento en caché de datos y la revalidación.</p>
</li>
<li>
<p><strong>Styling:</strong>	Soporte para sus métodos de estilo preferidos, incluidos los Módulos CSS, Tailwind CSS y CSS-in-JS</p>
</li>
<li>
<p><strong>Optimizations:</strong>	Optimizaciones de imágenes, fuentes y scripts para mejorar los Core Web Vitals y la experiencia del usuario de su aplicación.</p>
</li>
<li>
<p><strong>TypeScript:</strong>	Soporte mejorado para TypeScript, con una mejor comprobación de tipos y una compilación más eficiente, así como un complemento TypeScript personalizado y un comprobador de tipos.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_app_router_vs_pages_router">App Router vs Pages Router</h3>
<div class="paragraph">
<p>Next.js tiene dos enrutadores diferentes: el Enrutador de Aplicaciones y el Enrutador de Páginas. El Enrutador de Aplicaciones es un enrutador más nuevo que le permite utilizar las últimas características de React, como Server Components y streaming. El Enrutador de Páginas es el enrutador original de Next.js, que permite construir aplicaciones React renderizadas en el servidor y sigue siendo compatible con las aplicaciones antiguas de Next.js.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_instalar_next_js">instalar Next.js</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para comenzar a usar Next.js, primero debe instalarlo en su proyecto. Puede hacerlo utilizando npm o yarn.</p>
</div>
<div class="listingblock">
<div class="title">A continuación se muestra un ejemplo de cómo instalar Next.js con npx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">npx create-next-app@latest</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Esto creará un nuevo proyecto Next.js y habrá que contestar algunas preguntas para configurar el proyecto:</div>
<ul>
<li>
<p>What is your project named? my-app</p>
</li>
<li>
<p>Would you like to use TypeScript? No / Yes</p>
</li>
<li>
<p>Would you like to use ESLint? No / Yes</p>
</li>
<li>
<p>Would you like to use Tailwind CSS? No / Yes</p>
</li>
<li>
<p>Would you like to use <code>src/</code> directory? No / Yes</p>
</li>
<li>
<p>Would you like to use App Router? (recommended) No / Yes</p>
</li>
<li>
<p>Would you like to customize the default import alias (@/*)? No / Yes</p>
</li>
<li>
<p>What import alias would you like configured? @/*</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Otra alternativa es instalar Next.js con npm:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">npm install next@latest react@latest react-dom@latest</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">En el directorio de su proyecto, puede crear un archivo <code>package.json</code> con las siguientes dependencias:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fundamentos_de_rutado">Fundamentos de rutado</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El esqueleto de cada aplicación es el enrutamiento. Next.js utiliza un enrutador basado en el sistema de archivos que le permite definir rutas y estructuras de carpetas para crear una interfaz de usuario.</p>
</div>
<div class="sect2">
<h3 id="_terminología">Terminología</h3>
<div class="ulist">
<div class="title">Antes de comenzar, es importante comprender algunos términos clave relacionados con el enrutamiento en la web:</div>
<ul>
<li>
<p><strong>Árbol (Tree):</strong> Una convención para visualizar una estructura jerárquica. Por ejemplo, un árbol de componentes con componentes padres e hijos, una estructura de carpetas, etc.</p>
</li>
<li>
<p><strong>Subárbol (Subtree):</strong> Parte de un árbol, que comienza en una nueva raíz (primera) y termina en las hojas (última).</p>
</li>
<li>
<p><strong>Raíz (Root):</strong> El primer nodo en un árbol o subárbol, como un layout raíz.</p>
</li>
<li>
<p><strong>Hoja (Leaf):</strong> Nodos en un subárbol que no tienen hijos, como el último segmento en una ruta de URL.</p>
</li>
<li>
<p><strong>Segmento de URL (URL Segment)</strong>: Parte de la ruta de URL delimitada por barras.</p>
</li>
<li>
<p><strong>Ruta de URL (URL Path)</strong>: Parte de la URL que viene después del dominio (compuesta por segmentos).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_app_router">App Router</h3>
<div class="paragraph">
<p>En la versión 13, Next.js introdujo un nuevo App Router construido sobre <strong>Componentes de Servidor</strong> de React, que admite layouts compartidos, enrutamiento anidado, estados de carga, manejo de errores y más.</p>
</div>
<div class="paragraph">
<p>El App Router funciona en un nuevo directorio llamado app. El directorio de la aplicación funciona junto con el directorio de páginas para permitir la adopción incremental. Esto le permite optar por algunas rutas de su aplicación en el nuevo comportamiento mientras mantiene otras rutas en el directorio de páginas para el comportamiento anterior. Si su aplicación utiliza el directorio de páginas, consulte también la documentación del Enrutador de Páginas.</p>
</div>
<div class="paragraph">
<p>El App Router tiene prioridad sobre el Enrutador de Páginas. Las rutas en directorios no deben resolver a la misma ruta de URL y causarán un error en tiempo de compilación para evitar un conflicto.</p>
</div>
<div class="paragraph">
<p>Por defecto, los componentes dentro de app son Componentes de Servidor de React. Esta es una optimización de rendimiento y le permite adoptarlos fácilmente, y también puede usar Componentes de Cliente.</p>
</div>
</div>
<div class="sect2">
<h3 id="_roles_de_directorios_y_archivos">Roles de directorios y archivos</h3>
<div class="paragraph">
<p>Next.js usa un enrutador basado en el sistema de archivos donde:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los archivos se utilizan para crear una interfaz de usuario que se muestra para un segmento de ruta.</p>
</li>
<li>
<p>Cada directorio en una ruta representa un segmento de ruta. Cada segmento de ruta se asigna a un segmento correspondiente en una ruta de URL.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_rutas_anidadas">Rutas anidadas</h3>
<div class="paragraph">
<p>Para crear una ruta anidada, se anidan carpetas entre sí. Por ejemplo, puede agregar una nueva ruta /dashboard/settings anidando dos nuevas carpetas en el directorio de la aplicación.</p>
</div>
<div class="ulist">
<div class="title">La ruta /dashboard/settings se compone de tres segmentos:</div>
<ul>
<li>
<p><strong>/</strong> (Root segment)</p>
</li>
<li>
<p><strong>dashboard</strong> (Segment)</p>
</li>
<li>
<p><strong>settings</strong> (Leaf segment)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_archivos_especiales">Archivos especiales</h3>
<div class="ulist">
<div class="title">Next.js proporciona un conjunto de archivos especiales para crear una interfaz de usuario con un comportamiento específico en rutas anidadas:</div>
<ul>
<li>
<p><strong>page.tsx</strong>	UI única de una ruta y hacer que las rutas sean públicamente accesibles</p>
</li>
<li>
<p><strong>layout.tsx</strong>	UI compartida para un segmento y sus hijos</p>
</li>
<li>
<p><strong>template.tsx</strong>	UI de layout re-renderizado especializado</p>
</li>
<li>
<p><strong>route.tsx</strong>	Punto final de API del lado del servidor</p>
</li>
<li>
<p><strong>loading.tsx</strong>	UI de carga para un segmento y sus hijos</p>
</li>
<li>
<p><strong>not-found.tsx</strong>	UI no encontrada para un segmento y sus hijos</p>
</li>
<li>
<p><strong>error.tsx</strong>	UI de error para un segmento y sus hijos</p>
</li>
<li>
<p><strong>global-error.tsx</strong>	UI de error global</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_page_tsx">page.tsx</h4>
<div class="paragraph">
<p>Un archivo page.tsx es una interfaz de usuario única para una ruta. Puede definir una página exportando por defecto un componente desde un archivo page.tsx.</p>
</div>
<div class="ulist">
<div class="title">Propiedades de las páginas:</div>
<ul>
<li>
<p><strong>params:</strong> Parámetros del path de la URL.</p>
</li>
<li>
<p><strong>searchParams:</strong> Parámetros en la query de la URL.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de una página:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Page({
  params,
  searchParams,
}: {
  params: { slug: string }
  searchParams: { [key: string]: string | string[] | undefined }
}) {
  return &lt;h1&gt;My Page&lt;/h1&gt;
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. ejemplo de una página con parámetros de ruta:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Ejemplo</th>
<th class="tableblock halign-left valign-top">URL</th>
<th class="tableblock halign-left valign-top">params</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">app/shop/[slug]/page.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/shop/1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ slug: '1' }</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">app/shop/[category]/[item]/page.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/shop/1/2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ category: '1', item: '2' }</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">app/shop/[&#8230;&#8203;slug]/page.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/shop/1/2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ slug: ['1', '2'] }</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. ejemplo de una página con parámetros de query:</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">URL</th>
<th class="tableblock halign-left valign-top">searchParams</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/shop?a=1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ a: '1' }</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/shop?a=1&amp;b=2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ a: '1', b: '2' }</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/shop?a=1&amp;a=2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ a: ['1', '2'] }</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_layout_tsx">layout.tsx</h4>
<div class="paragraph">
<p>Un layout es una UI que se comparte entre varias rutas. Los layouts se utilizan para envolver un segmento de ruta y sus hijos en una UI común.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de un layout:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return &lt;section&gt;{children}&lt;/section&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un root layout es el layout más alto en el directorio de la aplicación raíz. Se utiliza para definir las etiquetas &lt;html&gt; y &lt;body&gt; y otras interfaces de usuario compartidas globalmente.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de un root layout:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;
        &lt;main&gt;{children}&lt;/main&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  )
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Propiedades de los layouts:</div>
<ul>
<li>
<p><strong>children:</strong> Componentes React que se envuelven en el layout.</p>
</li>
<li>
<p><strong>params:</strong> Parámetros de ruta de URL.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Tabla de ejemplos de parámetros de ruta:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Ejemplo</th>
<th class="tableblock halign-left valign-top">URL</th>
<th class="tableblock halign-left valign-top">params</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">app/dashboard/[team]/layout.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/dashboard/1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ team: '1' }</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">app/shop/[tag]/[item]/layout.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/shop/1/2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ tag: '1', item: '2' }</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">app/blog/[&#8230;&#8203;slug]/layout.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/blog/1/2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ slug: ['1', '2'] }</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Ejemplo de un layout con parámetros de ruta:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function ShopLayout({
  children,
  params,
}: {
  children: React.ReactNode
  params: {
    tag: string
    item: string
  }
}) {
  // URL -&gt; /shop/shoes/nike-air-max-97
  // `params` -&gt; { tag: 'shoes', item: 'nike-air-max-97' }
  return &lt;section&gt;{children}&lt;/section&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los layouts no pueden recibir parámetros en la query de la URL. Si necesitas acceder a los parámetros de la query, puedes usar page.tsx o route.tsx.</p>
</div>
</div>
<div class="sect3">
<h4 id="_template_tsx">template.tsx</h4>
<div class="paragraph">
<p>El archivo template.tsx es similar a un layout en el sentido de que envuelve cada layout secundario o página. A diferencia de los layouts que persisten en las rutas y mantienen el estado, los templates crean una nueva instancia para cada uno de sus hijos en la navegación.</p>
</div>
<div class="paragraph">
<p>Por defecto, template es un Componente de Servidor, pero también se puede utilizar como un Componente de Cliente a través de la directiva "use client".</p>
</div>
<div class="paragraph">
<p>Cuando un usuario navega entre rutas que comparten un template, se monta una nueva instancia del componente, se recrean los elementos DOM, no se conserva el estado y los efectos se vuelven a sincronizar.</p>
</div>
<div class="ulist">
<div class="title">Aunque es menos común, es posible usar un template en lugar de un layout si se necesita:</div>
<ul>
<li>
<p>Usar características que dependen de useEffect (por ejemplo, registrar vistas de página) y useState (por ejemplo, un formulario de comentarios por página).</p>
</li>
<li>
<p>Cambiar el comportamiento predeterminado del framework. Por ejemplo, los límites de Suspense dentro de los layouts solo muestran el fallback la primera vez que se carga el Layout y no al cambiar de página. Para los templates, el fallback se muestra en cada navegación.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Propiedades de los templates:</div>
<ul>
<li>
<p><strong>children:</strong> Componentes React que se envuelven en el template.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de un template:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Template({ children }: { children: React.ReactNode }) {
  return &lt;div&gt;{children}&lt;/div&gt;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_route_tsx">route.tsx</h4>
<div class="paragraph">
<p>El archivo route.tsx permite crear controladores de solicitud personalizados para una ruta determinada. Los siguientes métodos HTTP son compatibles: GET, POST, PUT, PATCH, DELETE, HEAD y OPTIONS. Suele estar en el directorio de la aplicación y se utiliza para manejar solicitudes de API del lado del servidor.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de un route.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export async function GET(request: Request) {}

export async function HEAD(request: Request) {}

export async function POST(request: Request) {}

export async function PUT(request: Request) {}

export async function DELETE(request: Request) {}

export async function PATCH(request: Request) {}

// If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and  set the appropriate Response `Allow` header depending on the other methods defined in the route handler.
export async function OPTIONS(request: Request) {}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Parámetros de los controladores de solicitud:</div>
<ul>
<li>
<p><strong>request:</strong> Objeto de solicitud HTTP.</p>
</li>
<li>
<p><strong>context:</strong> Objeto de contexto de la solicitud.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de un controlador de solicitud:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">type Params = {
  team: string
}

export async function GET(request: Request, context: { params: Params }) {
  const team = context.params.team // '1'
}

// Define params type according to your route parameters { tag: '1', item: '2' }
type Params = {
  tag: string
  item: string
}

export async function GET(request: Request, context: { params: Params }) {
  const tag = context.params.tag // '1'
  const item = context.params.item // '2'
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_loading_tsx">loading.tsx</h4>
<div class="paragraph">
<p>El archivo loading.tsx es una interfaz de usuario de carga que se muestra mientras se cargan los datos de una ruta. Se utiliza para mostrar un indicador de carga o un mensaje de espera mientras se obtienen los datos.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de un loading.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Loading() {
  // Or a custom loading skeleton component
  return &lt;p&gt;Loading...&lt;/p&gt;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_not_found_tsx">not-found.tsx</h4>
<div class="paragraph">
<p>El archivo not-found.tsx se utiliza para renderizar la interfaz de usuario cuando se lanza la función notFound dentro de un segmento de ruta. Junto con servir una interfaz de usuario personalizada, Next.js devolverá un código de estado HTTP 200 para respuestas en streaming y 404 para respuestas no en streaming.</p>
</div>
<div class="paragraph">
<p>Además de capturar los errores esperados de notFound(), el archivo raíz app/not-found.tsx también maneja cualquier URL no coincidente para toda su aplicación. Esto significa que los usuarios que visiten</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de un not-found.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Link from 'next/link'

export default function NotFound() {
  return (
    &lt;div&gt;
      &lt;h2&gt;Not Found&lt;/h2&gt;
      &lt;p&gt;Could not find requested resource&lt;/p&gt;
      &lt;Link href="/"&gt;Return Home&lt;/Link&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Por defecto, not-found es un Componente de Servidor. Se puede marcar como asíncrono para obtener y mostrar datos en la carga:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Link from 'next/link'
import { headers } from 'next/headers'

export default async function NotFound() {
  const headersList = headers()
  const domain = headersList.get('host')
  const data = await getSiteData(domain)
  return (
    &lt;div&gt;
      &lt;h2&gt;Not Found: {data.name}&lt;/h2&gt;
      &lt;p&gt;Could not find requested resource&lt;/p&gt;
      &lt;p&gt;
        View &lt;Link href="/blog"&gt;all posts&lt;/Link&gt;
      &lt;/p&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_error_tsx">error.tsx</h4>
<div class="paragraph">
<p>El archivo error.tsx define un límite de interfaz de usuario de error para un segmento de ruta.</p>
</div>
<div class="listingblock">
<div class="title">Se usa para capturar errores inesperados que ocurren en Componentes de Servidor y de Cliente y mostrar una interfaz de usuario de reserva:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client' // Error components must be Client Components

import { useEffect } from 'react'

export default function Error({
  error,
  reset,
}: {
  error: Error &amp; { digest?: string }
  reset: () =&gt; void
}) {
  useEffect(() =&gt; {
    // Log the error to an error reporting service
    console.error(error)
  }, [error])

  return (
    &lt;div&gt;
      &lt;h2&gt;Something went wrong!&lt;/h2&gt;
      &lt;button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () =&gt; reset()
        }
      &gt;
        Try again
      &lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Propiedades de la interfaz de usuario de error:</div>
<ul>
<li>
<p><strong>error:</strong> Objeto de error que contiene información sobre el error.</p>
<div class="ulist">
<ul>
<li>
<p><strong>message:</strong> Mensaje de error.</p>
</li>
<li>
<p><strong>digest:</strong> Identificador único del error.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>reset:</strong> Función de reinicio que intenta volver a renderizar el segmento.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_global_error_tsx">global-error.tsx</h4>
<div class="paragraph">
<p>Para manejar errores en el root layout, se puede usar un archivo global-error.tsx ubicado en el directorio raíz de la aplicación (app/global-error.tsx). global-error.tsx reemplaza a layout.tsx cuando está activo y, por lo tanto, debe definir sus propias etiquetas &lt;html&gt; y &lt;body&gt;.</p>
</div>
<div class="listingblock">
<div class="title">Un ejemplo de un global-error.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

export default function GlobalError({
  error,
  reset,
}: {
  error: Error &amp; { digest?: string }
  reset: () =&gt; void
}) {
  return (
    &lt;html&gt;
      &lt;body&gt;
        &lt;h2&gt;Something went wrong!&lt;/h2&gt;
        &lt;button onClick={() =&gt; reset()}&gt;Try again&lt;/button&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  )
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_definir_rutas">Definir rutas</h3>
<div class="paragraph">
<p>Next.js usa un enrutador basado en el sistema de archivos donde los directorios se utilizan para definir rutas.</p>
</div>
<div class="paragraph">
<p>Cada directorio representa un segmento de ruta que se asigna a un segmento de URL. Para crear una ruta anidada, puede anidar carpetas entre sí.</p>
</div>
<div class="paragraph">
<p>Un archivo especial page.tsx (page.js, page.tsx) se utiliza para hacer que los segmentos de ruta sean públicamente accesibles. Si no se proporciona un archivo page.tsx, la ruta se considera privada y no se puede acceder directamente.</p>
</div>
</div>
<div class="sect2">
<h3 id="_crear_una_ui">Crear una UI</h3>
<div class="paragraph">
<p>Next.js usa una convención de nombres para crear una interfaz de usuario en cada segmento de ruta. Los archivos especiales más comunes son páginas para mostrar una interfaz de usuario única para una ruta y layouts para mostrar una interfaz de usuario que se comparte en varias rutas.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para crear su primera página, agregue un archivo page.tsx dentro del directorio de la aplicación y exporte un componente React:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Page() {
  return &lt;h1&gt;Hello, Next.js!&lt;/h1&gt;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pages_y_layouts">Pages y layouts</h3>
<div class="paragraph">
<p>Los archivos especiales layout.tsx, page.tsx y template.tsx le permiten crear una interfaz de usuario para una ruta.</p>
</div>
<div class="sect3">
<h4 id="_pages">Pages</h4>
<div class="paragraph">
<p>Una Page es una interfaz de usuario única para una ruta. Puede definir una página exportando por defecto un componente desde un archivo page.tsx.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para crear su página de índice, agregue el archivo page.tsx dentro del directorio de la aplicación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">// `app/page.tsx` is the UI for the `/` URL
export default function Page() {
  return &lt;h1&gt;Hello, Home page!&lt;/h1&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para crear más páginas, hay que crear un nuevo directorio y agregar el archivo page.tsx dentro de éste. Por ejemplo, para crear una página para la ruta <strong>/dashboard</strong>, hay que crear un nuevo directorio llamado dashboard y agregar el archivo page.tsx dentro de éste:</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de una página de dashboard:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">// `app/dashboard/page.tsx` is the UI for the `/dashboard` URL
export default function Page() {
  return &lt;h1&gt;Hello, Dashboard Page!&lt;/h1&gt;
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En resumen:</div>
<ul>
<li>
<p>Las extensiones de archivo .js, .jsx o .tsx se pueden utilizar para las páginas.</p>
</li>
<li>
<p>Una página es siempre la hoja del subárbol de rutas.</p>
</li>
<li>
<p>Se requiere un archivo page.tsx para hacer que un segmento de ruta sea públicamente accesible.</p>
</li>
<li>
<p>Las páginas son Componentes de Servidor de forma predeterminada, pero se pueden configurar como Componentes de Cliente.</p>
</li>
<li>
<p>Las páginas pueden obtener datos. Consulte la sección Obtención de datos para obtener más información.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_layouts">Layouts</h4>
<div class="paragraph">
<p>Un layout es una interfaz de usuario que se comparte entre varias rutas. En la navegación, los layouts conservan el estado, siguen siendo interactivos y no se vuelven a renderizar. Los layouts también se pueden anidar.</p>
</div>
<div class="paragraph">
<p>Se puede definir un layout exportando por defecto un componente React desde un archivo layout.tsx. El componente debe aceptar una propiedad children que se rellenará con un layout secundario (si existe) o una página durante el renderizado.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, el layout se compartirá con las páginas /dashboard y /dashboard/settings:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function DashboardLayout({
  children, // will be a page or nested layout
}: {
  children: React.ReactNode
}) {
  return (
    &lt;section&gt;
      {/* Include shared UI here e.g. a header or sidebar */}
      &lt;nav&gt;&lt;/nav&gt;

      {children}
    &lt;/section&gt;
  )
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_root_layout">Root Layout</h4>
<div class="paragraph">
<p>EL root layout se define en el nivel superior del directorio de la aplicación y se aplica a todas las rutas. Este layout es obligatorio y debe contener etiquetas html y body, lo que le permite modificar el HTML inicial devuelto por el servidor.</p>
</div>
<div class="listingblock">
<div class="title">Ejemlo de un root layout:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;
        {/* Layout UI */}
        &lt;main&gt;{children}&lt;/main&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  )
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_layouts_anidados">Layouts anidados</h3>
<div class="paragraph">
<p>Por defecto, los layouts en la jerarquía de carpetas están anidados, lo que significa que envuelven los layouts secundarios a través de su propiedad children. Puede anidar layouts agregando layout.tsx dentro de segmentos de ruta específicos (directorios).</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para crear un layout para la ruta /dashboard, agregue un nuevo archivo layout.tsx dentro de la carpeta dashboard:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return &lt;section&gt;{children}&lt;/section&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si se combinan los dos layouts anteriores, el layout raíz (app/layout.tsx) envolvería el layout del panel de control (app/dashboard/layout.tsx), que envolvería los segmentos de ruta dentro de app/dashboard/*.</p>
</div>
<div class="ulist">
<div class="title">En resumen:</div>
<ul>
<li>
<p>Solo el layout raíz puede contener etiquetas &lt;html&gt; y &lt;body&gt;.</p>
</li>
<li>
<p>Cuando se define un archivo layout.tsx y page.tsx en la misma carpeta, el layout envolverá la página.</p>
</li>
<li>
<p>Los layouts son Componentes de Servidor de forma predeterminada, pero se pueden configurar como Componentes de Cliente.</p>
</li>
<li>
<p>Los layouts pueden obtener datos.</p>
</li>
<li>
<p>No es posible pasar datos entre un layout principal y sus hijos. Sin embargo, puede obtener los mismos datos en una ruta más de una vez, y React deduplicará automáticamente las solicitudes sin afectar el rendimiento.</p>
</li>
<li>
<p>Los layouts no tienen acceso a los segmentos de ruta debajo de sí mismos. Para acceder a todos los segmentos de ruta, puede usar useSelectedLayoutSegment o useSelectedLayoutSegments en un Componente de Cliente.</p>
</li>
<li>
<p>Puede usar Grupos de Rutas para incluir y excluir segmentos de ruta específicos en layouts compartidos.</p>
</li>
<li>
<p>Puede usar Grupos de Rutas para crear varios layouts raíz. Vea un ejemplo aquí.</p>
</li>
<li>
<p>Migración desde el directorio de páginas: el layout raíz reemplaza los archivos _app.js y _document.js. Consulte la guía de migración.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_templates">Templates</h3>
<div class="paragraph">
<p>Los templates son similares a los layouts en el sentido de que envuelven cada layout secundario o página. A diferencia de los layouts que persisten en las rutas y mantienen el estado, los templates crean una nueva instancia para cada uno de sus hijos en la navegación. Esto significa que cuando un usuario navega entre rutas que comparten un template, se monta una nueva instancia del componente, se recrean los elementos DOM, no se conserva el estado y los efectos se vuelven a sincronizar.</p>
</div>
<div class="ulist">
<div class="title">Puede haber casos en los que necesite esos comportamientos específicos, y los templates serían una opción más adecuada que los layouts. Por ejemplo:</div>
<ul>
<li>
<p>Caracteríasticas que dependen de useEffect (por ejemplo, registrar vistas de página) y useState (por ejemplo, un formulario de comentarios por página).</p>
</li>
<li>
<p>Para cambiar el comportamiento predeterminado del framework. Por ejemplo, los límites de Suspense dentro de los layouts solo muestran el fallback la primera vez que se carga el Layout y no al cambiar de página. Para los templates, el fallback se muestra en cada navegación.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Un template se puede definir exportando un componente React por defecto desde un archivo template.js. El componente debe aceptar una propiedad children.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Template({ children }: { children: React.ReactNode }) {
  return &lt;div&gt;{children}&lt;/div&gt;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">En términos de anidación, template.js se renderiza entre un layout y sus hijos. Aquí hay una salida simplificada:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">&lt;Layout&gt;
  {/* Note that the template is given a unique key. */}
  &lt;Template key={routeParam}&gt;{children}&lt;/Template&gt;
&lt;/Layout&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_metadata">Metadata</h3>
<div class="paragraph">
<p>No debemos añadir manualmente etiquetas &lt;head&gt; como &lt;title&gt; y &lt;meta&gt; a los layouts raíz. En su lugar, debemos usar la API de Metadata que maneja automáticamente requisitos avanzados como el streaming y la deduplicación de elementos &lt;head&gt;.</p>
</div>
<div class="paragraph">
<p>En el directorio de la aplicación, puede modificar los elementos HTML &lt;head&gt; como el título y meta utilizando las API de Metadata.</p>
</div>
<div class="listingblock">
<div class="title">Los metadatos se pueden definir exportando un objeto de metadatos o una función generateMetadata en un archivo layout.tsx o page.tsx.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Next.js',
}

export default function Page() {
  return '...'
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_enlaces_y_navegación">Enlaces y Navegación</h3>
<div class="ulist">
<div class="title">Hay cuatro formas de navegar entre rutas en Next.js:</div>
<ul>
<li>
<p>El componente &lt;Link&gt;</p>
</li>
<li>
<p>El hook useRouter (Componentes del Cliente)</p>
</li>
<li>
<p>La función de redirección (Componentes del Servidor)</p>
</li>
<li>
<p>El API de Historial nativa</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_componente_link">Componente &lt;Link&gt;</h4>
<div class="paragraph">
<p>&lt;Link&gt; es un componente integrado que extiende la etiqueta HTML &lt;a&gt; para proporcionar precarga y navegación del lado del cliente entre rutas. Es la forma principal y recomendada de navegar entre rutas en Next.js.</p>
</div>
<div class="listingblock">
<div class="title">Se puede usar importándolo desde next/link y pasando una propiedad href al componente:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Link from 'next/link'

export default function Page() {
  return &lt;Link href="/dashboard"&gt;Dashboard&lt;/Link&gt;
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Un resumen de las props disponibles para el componente Link:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Prop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ejemplo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Obligatorio</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">href</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">href="/dashboard"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String o Object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">replace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">replace={false}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">scroll</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">scroll={false}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">prefetch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">prefetch={false}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean o null</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Cuando se enlaza a segmentos dinámicos, se pueden usar literales de plantilla e interpolación para generar una lista de enlaces.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para generar una lista de publicaciones de blog:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Link from 'next/link'

export default function PostList({ posts }) {
  return (
    &lt;ul&gt;
      {posts.map((post) =&gt; (
        &lt;li key={post.id}&gt;
          &lt;Link href={`/blog/${post.slug}`}&gt;{post.title}&lt;/Link&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Es posible usar usePathname() para determinar si un enlace está activo. Por ejemplo, para agregar una clase al enlace activo, se puede comprobar si la ruta actual coincide con el href del enlace:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    &lt;nav&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/"&gt;
            Home
          &lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link
            className={`link ${pathname === '/about' ? 'active' : ''}`}
            href="/about"
          &gt;
            About
          &lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/nav&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>El comportamiento predeterminado del App Router de Next.js es desplazarse al principio de una nueva ruta o mantener la posición de desplazamiento para la navegación hacia atrás y hacia adelante.</p>
</div>
<div class="paragraph">
<p>Si quieres desplazarte a un id específico en la navegación, puedes añadir tu URL con un enlace de hash # o simplemente pasar un enlace de hash a la propiedad href. Esto es posible ya que &lt;Link&gt; se renderiza a un elemento &lt;a&gt;.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para desplazarse a un elemento con el id "section" en la página:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">&lt;Link href="/dashboard#settings"&gt;Settings&lt;/Link&gt;

// Output
&lt;a href="/dashboard#settings"&gt;Settings&lt;/a&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_el_hook_userouter">El hook useRouter</h4>
<div class="paragraph">
<p>El hook useRouter es una API de navegación que proporciona acceso a la ruta actual y a los métodos de navegación. Se puede utilizar en Componentes de Cliente para acceder a la ruta actual y a los métodos de navegación.</p>
</div>
<div class="listingblock">
<div class="title">El hook useRouter se puede importar desde next/navigation y se puede utilizar para acceder a la ruta actual y a los métodos de navegación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    &lt;button type="button" onClick={() =&gt; router.push('/dashboard')}&gt;
      Dashboard
    &lt;/button&gt;
  )
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Los métodos de navegación disponibles en el hook useRouter son:</div>
<ul>
<li>
<p><strong>router.push(href: string, { scroll: boolean }):</strong> Realiza una navegación del lado del cliente a la ruta proporcionada y agrega una nueva entrada en la pila de historial del navegador.</p>
</li>
<li>
<p><strong>router.replace(href: string, { scroll: boolean }):</strong> Realiza una navegación del lado del cliente a la ruta proporcionada sin agregar una nueva entrada en la pila de historial del navegador.</p>
</li>
<li>
<p><strong>router.refresh():</strong> Refresca la ruta actual. Realiza una nueva solicitud al servidor, vuelve a obtener las solicitudes de datos y vuelve a renderizar los Componentes del Servidor. El cliente fusionará la carga actualizada de Componentes de Servidor de React sin perder el estado de React del lado del cliente no afectado (por ejemplo, useState) o el estado del navegador (por ejemplo, la posición de desplazamiento).</p>
</li>
<li>
<p><strong>router.prefetch(href: string):</strong> Precarga la ruta proporcionada para transiciones más rápidas del lado del cliente.</p>
</li>
<li>
<p><strong>router.back():</strong> Navega hacia atrás a la ruta anterior en la pila de historial del navegador.</p>
</li>
<li>
<p><strong>router.forward():</strong> Navega hacia adelante a la siguiente página en la pila de historial del navegador.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_la_función_de_redirect">La función de redirect</h4>
<div class="paragraph">
<p>La función de redirección es una API de navegación que se puede utilizar en Componentes de Servidor para redirigir a una nueva ruta. La función de redirección se puede importar desde next/navigation y se puede utilizar para redirigir a una nueva ruta.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para redirigir a la ruta /login:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }: { params: { id: string } }) {
  const team = await fetchTeam(params.id)
  if (!team) {
    redirect('/login')
  }

  // ...
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En resumen:</div>
<ul>
<li>
<p>redirect devuelve un código de estado 307 (Redirección temporal) de forma predeterminada. Cuando se utiliza en una Acción del Servidor, devuelve un 303 (Ver Otro), que se utiliza comúnmente para redirigir a una página de éxito como resultado de una solicitud POST.</p>
</li>
<li>
<p>redirect lanza internamente un error, por lo que debe llamarse fuera de bloques try/catch.</p>
</li>
<li>
<p>redirect se puede llamar en Componentes del Cliente durante el proceso de renderizado, pero no en controladores de eventos. En su lugar, se puede utilizar el hook useRouter.</p>
</li>
<li>
<p>redirect también acepta URLs absolutas y se puede utilizar para redirigir a enlaces externos.</p>
</li>
<li>
<p>Si quieres redirigir antes del proceso de renderizado, utilice next.config.tsx o Middleware.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_api_de_historial_nativa">API de Historial nativa</h4>
<div class="paragraph">
<p>Next.js proporciona una API de Historial nativa que se puede utilizar para acceder a la pila de historial del navegador y a los métodos de navegación. La API de Historial nativa se puede utilizar en Componentes de Cliente para acceder a la pila de historial del navegador y a los métodos de navegación.</p>
</div>
<div class="paragraph">
<p>Podemos utilizar los métodos nativos <strong>window.history.pushState</strong> y <strong>window.history.replaceState</strong> para actualizar la pila de historial del navegador sin recargar la página.</p>
</div>
<div class="paragraph">
<p>PushState y replaceState se integran en el Router de Next.js, lo que le permite sincronizarse con usePathname y useSearchParams.</p>
</div>
<div class="listingblock">
<div class="title">window.history.pushState se usa para añadir una nueva entrada a la pila de historial del navegador. El usuario puede navegar hacia atrás al estado anterior. Por ejemplo, para ordenar una lista de productos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    &lt;&gt;
      &lt;button onClick={() =&gt; updateSorting('asc')}&gt;Sort Ascending&lt;/button&gt;
      &lt;button onClick={() =&gt; updateSorting('desc')}&gt;Sort Descending&lt;/button&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">window.history.replaceState se usa para reemplazar la entrada actual en la pila de historial del navegador. El usuario no puede navegar hacia atrás al estado anterior. Por ejemplo, para cambiar la configuración regional de la aplicación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // e.g. '/en/about' or '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    &lt;&gt;
      &lt;button onClick={() =&gt; switchLocale('en')}&gt;English&lt;/button&gt;
      &lt;button onClick={() =&gt; switchLocale('fr')}&gt;French&lt;/button&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_carga_de_ui_y_streaming">Carga de UI y Streaming</h3>
<div class="paragraph">
<p>El archivo archivo loading.tsx se usa para crear una interfaz de usuario de carga significativa con React Suspense. Con esta convención, se puede mostrar un estado de carga instantáneo desde el servidor mientras se carga el contenido de un segmento de ruta. El nuevo contenido se intercambia automáticamente una vez que se completa el renderizado.</p>
</div>
<div class="sect3">
<h4 id="_instant_loading_states">Instant Loading States</h4>
<div class="paragraph">
<p>Un <strong>instant loading state</strong> es una interfaz de usuario de reserva que se muestra inmediatamente al navegar. Puede pre-renderizar indicadores de carga como esqueletos y spinners, o una parte pequeña pero significativa de futuras pantallas como una foto de portada, título, etc. Esto ayuda a los usuarios a entender que la aplicación está respondiendo y proporciona una mejor experiencia de usuario.</p>
</div>
<div class="listingblock">
<div class="title">Crear un estado de carga añadiendo un archivo loading.js dentro de un directorio.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Loading() {
  // You can add any UI inside Loading, including a Skeleton.
  return &lt;LoadingSkeleton /&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el mismo directorio, loading.js se anidará dentro de layout.tsx. Envolverá automáticamente el archivo page.tsx y cualquier hijo en un límite de &lt;Suspense&gt;.</p>
</div>
<div class="ulist">
<div class="title">En resumen:</div>
<ul>
<li>
<p>Navigation es inmediata, incluso con enrutamiento centrado en el servidor.</p>
</li>
<li>
<p>Navigation es interrumpible, lo que significa que cambiar de ruta no necesita esperar a que el contenido de la ruta se cargue completamente antes de navegar a otra ruta.</p>
</li>
<li>
<p>Los Shared Layouts siguen siendo interactivos mientras se cargan los nuevos segmentos de ruta.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_streaming_con_suspense">Streaming con Suspense</h4>
<div class="paragraph">
<p>Además de loading.js, también se pueden crear manualmente Límites de Suspense para sus propios componentes de interfaz de usuario. El App Router admite el streaming con Suspense para los entornos de Node.js y Edge.</p>
</div>
<div class="paragraph">
<p>Algunos navegadores almacenan en búfer una respuesta en streaming. Es posible que no vea la respuesta en streaming hasta que supere los 1024 bytes. Esto suele afectar solo a las aplicaciones "hola mundo", pero no a las aplicaciones reales.</p>
</div>
<div class="paragraph">
<p>Para comprender cómo funciona el streaming en React y Next.js, es útil entender el Renderizado del Lado del Servidor (SSR) y sus limitaciones.</p>
</div>
<div class="paragraph">
<div class="title">Con SSR, hay una serie de pasos que deben completarse antes de que un usuario pueda ver e interactuar con una página:</div>
<p>1.- Se obtienen todos los datos de una página determinada en el servidor.
2.- El servidor luego renderiza el HTML para la página.
3.- El HTML, CSS y JavaScript de la página se envían al cliente.
4.- Se muestra una interfaz de usuario no interactiva utilizando el HTML y CSS generados.
5.- Finalmente, React hidrata la interfaz de usuario para hacerla interactiva.</p>
</div>
<div class="paragraph">
<p>Estos pasos son secuenciales y bloqueantes, lo que significa que el servidor solo puede renderizar el HTML de una página una vez que se han obtenido todos los datos. Y, en el cliente, React solo puede hidratar la interfaz de usuario una vez que se ha descargado el código de todos los componentes de la página.</p>
</div>
<div class="paragraph">
<p>SSR con React y Next.js ayuda a mejorar el rendimiento de carga percibido mostrando una página no interactiva al usuario lo antes posible.</p>
</div>
<div class="paragraph">
<p>Sin embargo, todavía puede ser lento, ya que todas las solicitudes de datos en el servidor deben completarse antes de que la página se pueda mostrar al usuario.</p>
</div>
<div class="paragraph">
<p>Los mecanismos de Streaming permiten dividir el HTML de la página en trozos más pequeños y enviar progresivamente esos trozos del servidor al cliente.</p>
</div>
<div class="paragraph">
<p>Streaming funciona bien con el modelo de componentes de React porque cada componente se puede considerar un fragmento. Los componentes que tienen una prioridad más alta (por ejemplo, información del producto) o que no dependen de datos se pueden enviar primero (por ejemplo, layout), y React puede comenzar la hidratación antes. Los componentes que tienen una prioridad más baja (por ejemplo, reseñas, productos relacionados) se pueden enviar en la misma solicitud del servidor después de que se hayan obtenido sus datos.</p>
</div>
<div class="paragraph">
<p>&lt;Suspense&gt; funciona envolviendo un componente que realiza una acción asíncrona (por ejemplo, obtener datos), mostrando una interfaz de usuario de reserva (por ejemplo, esqueleto, spinner) mientras se está realizando, y luego intercambiando su componente una vez que se completa la acción.</p>
</div>
<div class="listingblock">
<div class="title">Un ejemplo de cómo usar Suspense con un componente de carga diferida:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { Suspense } from 'react'
import { PostFeed, Weather } from './Components'

export default function Posts() {
  return (
    &lt;section&gt;
      &lt;Suspense fallback={&lt;p&gt;Loading feed...&lt;/p&gt;}&gt;
        &lt;PostFeed /&gt;
      &lt;/Suspense&gt;
      &lt;Suspense fallback={&lt;p&gt;Loading weather...&lt;/p&gt;}&gt;
        &lt;Weather /&gt;
      &lt;/Suspense&gt;
    &lt;/section&gt;
  )
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Al usar Suspense, obtienes los beneficios de:</div>
<ul>
<li>
<p><strong>Streaming Server Rendering</strong> renderiza progresivamente HTML desde el servidor al cliente.</p>
</li>
<li>
<p><strong>Hidratación selectiva</strong> - React prioriza qué componentes hacer interactivos primero en función de la interacción del usuario.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cuando se usa streaming, se devolverá un código de estado 200 para indicar que la solicitud se ha completado correctamente.</p>
</div>
<div class="paragraph">
<p>El servidor todavía puede comunicar errores o problemas al cliente dentro del contenido transmitido en sí, por ejemplo, al usar <strong>redirect</strong> o <strong>notFound</strong>. Dado que las cabeceras de respuesta ya se han enviado al cliente, el código de estado de la respuesta no se puede actualizar. Esto no afecta al SEO.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_manejo_de_errores">Manejo de errores</h3>
<div class="ulist">
<div class="title">El archivo error.js le permite manejar de forma elegante los errores inesperados en las rutas anidadas.</div>
<ul>
<li>
<p>Envuelve automáticamente un segmento de ruta y sus hijos anidados en un límite de error de React.</p>
</li>
<li>
<p>Crea una interfaz de usuario de error adaptada a segmentos específicos utilizando la jerarquía del sistema de archivos para ajustar la granularidad.</p>
</li>
<li>
<p>Aísla los errores a los segmentos afectados mientras mantiene el resto de la aplicación funcional.</p>
</li>
<li>
<p>Agrega funcionalidad para intentar recuperarse de un error sin tener que recargar la página completa.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Para crear una interfaz de usuario de error, añade un archivo error.js dentro de un segmento de ruta y exporta un componente React:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client' // Error components must be Client Components

import { useEffect } from 'react'

export default function Error({
  error,
  reset,
}: {
  error: Error &amp; { digest?: string }
  reset: () =&gt; void
}) {
  useEffect(() =&gt; {
    // Log the error to an error reporting service
    console.error(error)
  }, [error])

  return (
    &lt;div&gt;
      &lt;h2&gt;Something went wrong!&lt;/h2&gt;
      &lt;button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () =&gt; reset()
        }
      &gt;
        Try again
      &lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Cómo funciona error.js:</div>
<ul>
<li>
<p>error.js crea automáticamente un límite de error de React que envuelve un componente secundario anidado o page.tsx.</p>
</li>
<li>
<p>El componente de React exportado desde el archivo error.js se utiliza como el componente de reserva.</p>
</li>
<li>
<p>Si se produce un error dentro del límite de error, el error se contiene y se renderiza el componente de reserva.</p>
</li>
<li>
<p>Cuando el componente de error de reserva está activo, los layouts por encima del límite de error mantienen su estado y siguen siendo interactivos, y el componente de error puede mostrar funcionalidad para recuperarse del error.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un componente de error puede utilizar la función reset() para pedir al usuario que intente recuperarse del error. Cuando se ejecuta, la función intentará volver a renderizar el contenido del límite de error. Si tiene éxito, el componente de error de reserva se reemplaza por el resultado del nuevo renderizado.</p>
</div>
<div class="listingblock">
<div class="title">Un ejemplo de cómo usar error.js:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

export default function Error({
  error,
  reset,
}: {
  error: Error &amp; { digest?: string }
  reset: () =&gt; void
}) {
  return (
    &lt;div&gt;
      &lt;h2&gt;Something went wrong!&lt;/h2&gt;
      &lt;button onClick={() =&gt; reset()}&gt;Try again&lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los límites de error de error.js no capturan errores lanzados en los componentes layout.tsx o template.js del mismo segmento. Esta jerarquía intencional mantiene visible y funcional la interfaz de usuario importante que se comparte entre rutas hermanas (como la navegación) cuando se produce un error.</p>
</div>
<div class="ulist">
<div class="title">Soluciones alternativas para manejar errores en layouts y templates:</div>
<ul>
<li>
<p>Para manejar errores dentro de un layout o template específico: coloca un archivo error.js en el segmento padre del layout.</p>
</li>
<li>
<p>Para manejar errores dentro del layout o template raíz: use una variación de error.js llamada global-error.tsx.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El límite de error app/error.js raíz no captura errores lanzados en el componente raíz app/layout.tsx o app/template.js.
Para manejar errores en los componentes raíz, hay que definir un archivo global-error.tsx en el directorio raíz de la aplicación.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para manejar errores en el root layout en un archivo global-error.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

export default function GlobalError({
  error,
  reset,
}: {
  error: Error &amp; { digest?: string }
  reset: () =&gt; void
}) {
  return (
    &lt;html&gt;
      &lt;body&gt;
        &lt;h2&gt;Something went wrong!&lt;/h2&gt;
        &lt;button onClick={() =&gt; reset()}&gt;Try again&lt;/button&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  )
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_errores_en_server_components">Errores en Server Components</h4>
<div class="paragraph">
<p>Si se produce un error dentro de un Componente del Servidor, Next.js enviará un objeto Error al archivo error.js más cercano como la propiedad error. Este objeto de error solo incluye un mensaje genérico y la propiedad de resumen en producción, pero en desarrollo, incluye un objeto con información detallada sobre el error.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_redirecciones">Redirecciones</h3>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Tabla de modos de redirección:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">API</th>
<th class="tableblock halign-left valign-top">Propósito</th>
<th class="tableblock halign-left valign-top">Dónde</th>
<th class="tableblock halign-left valign-top">Código de Estado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">redirect</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redirige al usuario después de una mutación o evento</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Componentes del servidor, Acciones del servidor, Manejadores de rutas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">307 Redirección Temporal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">permanentRedirect</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redirige al usuario después de una mutación o evento</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Componentes del servidor, Acciones del servidor, Manejadores de rutas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">308 Redirección Permanente</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">useRouter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Realiza una navegación del lado del cliente</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Manejadores de eventos en Componentes del cliente</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">redirects en next.config.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redirige una solicitud entrante basada en una ruta</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Archivo next.config.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">307 Redirección Temporal o 308 Redirección Permanente</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NextResponse.redirect</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redirige una solicitud entrante basada en una condición</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Middleware</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cualquiera</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_la_función_redirect">La función redirect</h4>
<div class="paragraph">
<p>La función redirect es una API de redirección que se puede utilizar en Componentes del Servidor, Server Actions y Route Handlers para redirigir a una nueva ruta. La función redirect se puede importar desde next/navigation y se puede utilizar para redirigir a una nueva ruta.</p>
</div>
<div class="listingblock">
<div class="title">redirect se usa a menudo después de una mutación o evento. Por ejemplo, crear una publicación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use server'

import { redirect } from 'next/navigation'
import { revalidatePath } from 'next/cache'

export async function createPost(id: string) {
  try {
    // Call database
  } catch (error) {
    // Handle errors
  }

  revalidatePath('/posts') // Update cached posts
  redirect(`/post/${id}`) // Navigate to the new post page
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En resumen:</div>
<ul>
<li>
<p>redirect devuelva un código de estado 307 (Redirección temporal) de forma predeterminada. Cuando se utiliza en una Acción del Servidor, devuelve un 303 (Ver Otro), que se utiliza comúnmente para redirigir a una página de éxito como resultado de una solicitud POST.</p>
</li>
<li>
<p>redirect lanza internamente un error, por lo que debe llamarse fuera de bloques try/catch.</p>
</li>
<li>
<p>redirect se puede llamar en Componentes del Cliente durante el proceso de renderizado, pero no en controladores de eventos. En su lugar, se puede utilizar el hook useRouter.</p>
</li>
<li>
<p>redirect también acepta URLs absolutas y se puede utilizar para redirigir a enlaces externos.</p>
</li>
<li>
<p>Si se quiere redirigir antes del proceso de renderizado, utilice next.config.tsx o Middleware.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_la_función_permanentredirect">La función permanentRedirect</h4>
<div class="paragraph">
<p>La función permanentRedirect te permite redirigir permanentemente al usuario a otra URL. Puedes llamar a permanentRedirect en Componentes del Servidor, Route Handlers y Server Actions.</p>
</div>
<div class="listingblock">
<div class="title">Se suele utilizar permanentRedirect después de una mutación o evento que cambia la URL canónica de una entidad, como actualizar la URL de perfil de un usuario después de cambiar su nombre de usuario</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use server'

import { permanentRedirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function updateUsername(username: string, formData: FormData) {
  try {
    // Call database
  } catch (error) {
    // Handle errors
  }

  revalidateTag('username') // Update all references to the username
  permanentRedirect(`/profile/${username}`) // Navigate to the new user profile
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En resumen:</div>
<ul>
<li>
<p>permanentRedirect devuelve un código de estado 308 (redirección permanente) por defecto.</p>
</li>
<li>
<p>permanentRedirect también acepta URLs absolutas y se puede utilizar para redirigir a enlaces externos.</p>
</li>
<li>
<p>Si se quiere redirigir antes del proceso de renderizado, hay que usar next.config.tsx o Middleware.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_el_hook_userouter_2">El hook useRouter</h4>
<div class="paragraph">
<p>El hook useRouter es una API de navegación que proporciona acceso a la ruta actual y a los métodos de navegación. Se puede utilizar en Componentes de Cliente para acceder a la ruta actual y a los métodos de navegación. Si no es necesario navegar programáticamente, es preferible utilizar el componente &lt;Link&gt; en lugar del hook useRouter.</p>
</div>
<div class="listingblock">
<div class="title">Si necesitas redirigir dentro de un controlador de eventos en un Componente de Cliente, puedes utilizar el método push del hook useRouter. Por ejemplo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    &lt;button type="button" onClick={() =&gt; router.push('/dashboard')}&gt;
      Dashboard
    &lt;/button&gt;
  )
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_redirecciones_en_next_config_tsx">Redirecciones en next.config.tsx</h4>
<div class="paragraph">
<p>Las redirecciones en el archivo next.config.tsx permiten redirigir una ruta de solicitud entrante a una ruta de destino diferente. Esto es útil cuando cambias la estructura de URL de las páginas o tienes una lista de redirecciones que se conocen de antemano.</p>
</div>
<div class="paragraph">
<p>redirects admite la coincidencia de ruta, header, cookie y query, lo que te da la flexibilidad de redirigir a los usuarios en función de una solicitud entrante.</p>
</div>
<div class="listingblock">
<div class="title">Para usar redirecciones, añade la opción a tu archivo next.config.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">module.exports = {
  async redirects() {
    return [
      // Basic redirect
      {
        source: '/about',
        destination: '/',
        permanent: true,
      },
      // Wildcard path matching
      {
        source: '/blog/:slug',
        destination: '/news/:slug',
        permanent: true,
      },
    ]
  },
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En resumen:</div>
<ul>
<li>
<p>redirects puede devolver un código de estado 307 (Redirección temporal) o 308 (Redirección permanente) con la opción permanent.</p>
</li>
<li>
<p>redirects podría tener un límite en las plataformas. Por ejemplo, algunas plataformas pueden tener límite de 1.024 redirecciones. Para gestionar un gran número de redirecciones (1000+), considera crear una solución personalizada utilizando Middleware.</p>
</li>
<li>
<p>redirects se ejecuta antes de Middleware.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_nextresponse_redirect_en_middleware">NextResponse.redirect en Middleware</h4>
<div class="paragraph">
<p>Middleware nos permite ejecutar código antes de que se complete una solicitud. Luego, en función de la solicitud entrante, redirigir a una URL diferente utilizando NextResponse.redirect. Esto es útil si quieres redirigir a los usuarios en función de una condición (por ejemplo, autenticación, gestión de sesiones, etc.) o tienes un gran número de redirecciones. Middleware se ejecuta después de las redirecciones en next.config.tsx y antes del renderizado.</p>
</div>
<div class="listingblock">
<div class="title">Para redirigir en Middleware, añade la función redirect a tu Middleware en un archivo middleware.js:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { NextResponse, NextRequest } from 'next/server'
import { authenticate } from 'auth-provider'

export function middleware(request: NextRequest) {
  const isAuthenticated = authenticate(request)

  // If the user is authenticated, continue as normal
  if (isAuthenticated) {
    return NextResponse.next()
  }

  // Redirect to login page if not authenticated
  return NextResponse.redirect(new URL('/login', request.url))
}

export const config = {
  matcher: '/dashboard/:path*',
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_redirecciones_a_gran_escala">Gestión de redirecciones a gran escala</h4>
<div class="paragraph">
<p>Si tienes un gran número de redirecciones (1000+), considera crear una solución personalizada utilizando Middleware. Esto te permite gestionar redirecciones a gran escala de forma eficiente y sin afectar el rendimiento de tu aplicación.</p>
</div>
<div class="ulist">
<div class="title">Para hacer ésto:</div>
<ul>
<li>
<p>Crear y almacenar un mapa de redirecciones</p>
</li>
<li>
<p>Optimizar el rendimiento de la búsqueda de datos</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Un ejemplo de cómo crear un mapa de redirecciones en un archivo redirects.json:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "/old": {
    "destination": "/new",
    "permanent": true
  },
  "/blog/post-old": {
    "destination": "/blog/post-new",
    "permanent": true
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Luego, en tu Middleware, puedes cargar el archivo JSON y buscar la ruta de solicitud entrante en el mapa de redirecciones:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { NextResponse, NextRequest } from 'next/server'
import { get } from '@vercel/edge-config'

type RedirectEntry = {
  destination: string
  permanent: boolean
}

export async function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname
  const redirectData = await get(pathname)

  if (redirectData &amp;&amp; typeof redirectData === 'string') {
    const redirectEntry: RedirectEntry = JSON.parse(redirectData)
    const statusCode = redirectEntry.permanent ? 308 : 307
    return NextResponse.redirect(redirectEntry.destination, statusCode)
  }

  // No redirect found, continue without redirecting
  return NextResponse.next()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_route_groups">Route Groups</h3>
<div class="paragraph">
<p>En el directorio de la aplicación, los directorios anidados se asignan normalmente a rutas URL. Sin embargo, puedes marcar una carpeta como Grupo de Rutas para evitar que el directorio se incluya en la ruta de la URL.</p>
</div>
<div class="paragraph">
<p>Esto permite organizar segmentos de ruta y archivos de proyecto en grupos lógicos sin afectar la estructura de la ruta de la URL.</p>
</div>
<div class="ulist">
<div class="title">Los route groups son útiles para:</div>
<ul>
<li>
<p>Organizar archivos de proyecto en grupos lógicos.</p>
</li>
<li>
<p>Evitar que los directorios anidados se incluyan en la ruta de la URL.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para organizar rutas sin afectar la URL, se crea un grupo para mantener juntas las rutas relacionadas. Los directorios entre paréntesis se omitirán de la URL (por ejemplo, (marketing) o (shop)).</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para organizar rutas de marketing y tienda en grupos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-file hljs" data-lang="file">pages/
├── (marketing)
│   ├── about
│       └── page.tsx
│   ├── contact
│       └── page.tsx
└── (shop)
    ├── products
        └── page.tsx</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En resumen:</div>
<ul>
<li>
<p>El nombre de los grupos de rutas no tiene ningún significado especial aparte de la organización. No afectan a la ruta de la URL.</p>
</li>
<li>
<p>Las rutas que incluyen un grupo de rutas no deben resolverse a la misma ruta de URL que otras rutas. Por ejemplo, dado que los grupos de rutas no afectan a la estructura de la URL, (marketing)/about/page.tsx y (shop)/about/page.tsx se resolverían a /about y causarían un error.</p>
</li>
<li>
<p>Si utilizas varios layouts raíz sin un archivo layout.tsx de nivel superior, tu archivo de página de inicio.js debe definirse en uno de los grupos de rutas. Por ejemplo: app/(marketing)/page.tsx.</p>
</li>
<li>
<p>Navegar entre varios layouts raíz provocará una carga completa de la página (en lugar de una navegación del lado del cliente). Por ejemplo, navegar desde /cart que utiliza app/(shop)/layout.tsx a /blog que utiliza app/(marketing)/layout.tsx provocará una carga completa de la página. Esto solo se aplica a varios layouts raíz.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_rutas_dinámicas">Rutas dinámicas</h3>
<div class="paragraph">
<p>Las rutas dinámicas permiten crear rutas que se adaptan a diferentes URL sin tener que crear una ruta para cada URL. Esto es útil para crear rutas que contienen parámetros variables, como rutas de blog, rutas de productos o rutas de usuario.</p>
</div>
<div class="paragraph">
<p>Un Segmento Dinámico se puede crear envolviendo el nombre de una carpeta entre corchetes: [nombreCarpeta]. Por ejemplo, [id] o [slug].</p>
</div>
<div class="paragraph">
<p>Los Segmentos Dinámicos se pasan como la propiedad params a las funciones layout, page, route y generateMetadata.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, un blog podría incluir la siguiente ruta app/blog/[slug]/page.tsx donde [slug] es el Segmento Dinámico para las publicaciones de blog.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Page({ params }: { params: { slug: string } }) {
  return &lt;div&gt;My Post: {params.slug}&lt;/div&gt;
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_generación_estática_de_parámetros">Generación estática de parámetros</h4>
<div class="paragraph">
<p>La función generateStaticParams se puede utilizar en combinación con segmentos de ruta dinámicos para generar rutas estáticamente en el momento de la compilación en lugar de a pedido en el momento de la solicitud.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para generar rutas estáticas para publicaciones de blog en app/blog/[slug]/page.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) =&gt; res.json())

  return posts.map((post) =&gt; ({
    slug: post.slug,
  }))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>El principal beneficio de la función generateStaticParams es su recuperación inteligente de datos. Si el contenido se obtiene dentro de la función generateStaticParams utilizando una solicitud fetch, las solicitudes se almacenan en caché automáticamente. Esto significa que una solicitud fetch con los mismos argumentos en varios generateStaticParams, Layouts y Pages solo se realizará una vez, lo que reduce los tiempos de compilación.</p>
</div>
<div class="paragraph">
<p>Los Segmentos Dinámicos se pueden extender para capturar todos los segmentos subsiguientes añadiendo una elipsis dentro de los corchetes [&#8230;&#8203;nombreDirectorio].</p>
</div>
<div class="paragraph">
<p>Por ejemplo, app/shop/[&#8230;&#8203;slug]/page.tsx coincidirá con /shop/clothes, pero también con /shop/clothes/tops, /shop/clothes/tops/t-shirts, y así sucesivamente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_segmentos_catch_all">Segmentos Catch-all</h4>
<div class="paragraph">
<p>Dynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets [&#8230;&#8203;folderName].
Los Segmentos Dinámicos se pueden extender para capturar todos los segmentos subsiguientes añadiendo una elipsis dentro de los corchetes [&#8230;&#8203;nombreDirectorio].</p>
</div>
<div class="paragraph">
<p>Por ejemplo, app/shop/[&#8230;&#8203;slug]/page.tsx coincidirá con /shop/clothes, pero también con /shop/clothes/tops, /shop/clothes/tops/t-shirts, y así sucesivamente.</p>
</div>
<div class="paragraph">
<p>Los Segmentos Catch-all se pueden hacer opcionales incluyendo el parámetro entre corchetes dobles: [[&#8230;&#8203;nombreDirectorio]].</p>
</div>
<div class="paragraph">
<p>Por ejemplo, app/shop/[[&#8230;&#8203;slug]]/page.tsx también coincidirá con /shop, además de /shop/clothes, /shop/clothes/tops, /shop/clothes/tops/t-shirts.</p>
</div>
<div class="paragraph">
<p>La diferencia entre los segmentos catch-all y los segmentos catch-all opcionales es que con los opcionales, también se empareja la ruta sin el parámetro (/shop en el ejemplo anterior).</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para crear una ruta catch-all opcional en app/shop/[[&#8230;&#8203;slug]]/page.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Page({ params }: { params: { slug: string[] } }) {
  return &lt;div&gt;Shop: {params.slug.join('/')}&lt;/div&gt;
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Tenemos que tener en cuenta los tipos de datos que se pueden utilizar en los Segmentos Dinámicos en la siguiente tabla:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Segmento Dinámico</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ruta</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parámetros</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">app/shop/[[&#8230;&#8203;slug]]/page.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/shop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">app/shop/[[&#8230;&#8203;slug]]/page.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/shop/a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ slug: ['a'] }</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">app/shop/[[&#8230;&#8203;slug]]/page.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/shop/a/b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ slug: ['a', 'b'] }</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">app/shop/[[&#8230;&#8203;slug]]/page.tsx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/shop/a/b/c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ slug: ['a', 'b', 'c'] }</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_rutas_paralelas">Rutas paralelas</h3>
<div class="paragraph">
<p>Las rutas paralelas te permiten renderizar simultáneamente o condicionalmente una o más páginas dentro del mismo layout. Son útiles para secciones altamente dinámicas de una aplicación, como paneles o dashboards, donde se necesita mostrar varias páginas al mismo tiempo.</p>
</div>
<div class="sect3">
<h4 id="_slots">Slots</h4>
<div class="paragraph">
<p>Las rutas paralelas se crean utilizando <strong>slots</strong> con la convención <strong>@nombreDirectorio</strong>. Los slots se pasan como props al layout principal compartido. Por ejemplo, la siguiente estructura de archivos define dos slots: @analytics y @team.</p>
</div>
<div class="listingblock">
<div class="title">Para el ejemplo anterior, el componente en app/layout.tsx ahora acepta las props de los slots @analytics y @team, y puede renderizarlos en paralelo junto con la prop children:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Layout({
  children,
  team,
  analytics,
}: {
  children: React.ReactNode
  analytics: React.ReactNode
  team: React.ReactNode
}) {
  return (
    &lt;&gt;
      {children}
      {team}
      {analytics}
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el ejemplo anterior, el componente Layout renderiza el contenido de children, team y analytics en paralelo. Esto significa que el contenido de team y analytics se renderiza simultáneamente con el contenido de children. La prop children es un slot implícito que no necesita ser mapeado a una carpeta. Esto significa que app/page.tsx es equivalente a app/@children/page.tsx.</p>
</div>
</div>
<div class="sect3">
<h4 id="_estado_activo_y_navegación">Estado activo y navegación</h4>
<div class="ulist">
<div class="title">Por defecto, Next.js realiza un seguimiento del estado activo (o subpágina) para cada slot. Sin embargo, el contenido renderizado dentro de un slot dependerá del tipo de navegación:</div>
<ul>
<li>
<p><strong>Soft Navigation:</strong> Durante la navegación del lado del cliente, Next.js realizará un renderizado parcial, cambiando la subpágina dentro del slot, mientras mantiene las subpáginas activas de los otros slots, incluso si no coinciden con la URL actual.</p>
</li>
<li>
<p><strong>Hard Navigation:</strong> Después de una carga completa de la página (actualización del navegador), Next.js no puede determinar el estado activo para los slots que no coinciden con la URL actual. En su lugar, renderizará un archivo default.js para los slots no coincidentes, o 404 si default.js no existe.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Se puede definir un archivo default.js para renderizar como un fallback para los slots no coincidentes durante la carga inicial o la recarga de la página completa.</p>
</div>
<div class="listingblock">
<div class="title">Considera la siguiente estructura de carpetas. El slot @team tiene una página /settings, pero @analytics no.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-file hljs" data-lang="file">app/
├── @analytics
│   └── settings
│       └── page.tsx
├── @team
│   └── default.js
|   └── page.tsx
├── default.js
├── layout.tsx
└── page.tsx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando se navega a /settings, el slot @team renderizará la página /settings mientras mantiene la página activa actual para el slot @analytics. Al recargar, Next.js renderizará un default.js para @analytics. Si default.js no existe, se renderizará un 404 en su lugar.</p>
</div>
<div class="paragraph">
<p>Además, dado que children es un slot implícito, también necesitas crear un archivo default.js para renderizar un fallback para children cuando Next.js no puede recuperar el estado activo de la página principal.</p>
</div>
</div>
<div class="sect3">
<h4 id="_useselectedlayoutsegments">useSelectedLayoutSegment(s)</h4>
<div class="paragraph">
<p>Ambas funciones useSelectedLayoutSegment y useSelectedLayoutSegments aceptan un parámetro parallelRoutesKey, que te permite leer el segmento de ruta activo dentro de un slot.</p>
</div>
<div class="listingblock">
<div class="title">Cuando un usuario navega a app/@auth/login (o /login en la barra de direcciones), loginSegment será igual a la cadena "login".</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { useSelectedLayoutSegment } from 'next/navigation'

export default function Layout({ auth }: { auth: React.ReactNode }) {
  const loginSegment = useSelectedLayoutSegment('auth')
  // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplos_de_uso_de_rutas_paralelas">Ejemplos de uso de rutas paralelas</h4>
<div class="ulist">
<div class="title">Podemos utilizar rutas paralelas en casos de uso como:</div>
<ul>
<li>
<p>Rutas dicionales</p>
</li>
<li>
<p>Grupos de tabs</p>
</li>
<li>
<p>Modales</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Rutas condicionales:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { checkUserRole } from '@/lib/auth'

export default function Layout({
  user,
  admin,
}: {
  user: React.ReactNode
  admin: React.ReactNode
}) {
  const role = checkUserRole()
  return &lt;&gt;{role === 'admin' ? admin : user}&lt;/&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usamos las rutas paralelas para renderizar condicionalmente rutas basadas en ciertas condiciones, como el rol de usuario. Por ejemplo, para renderizar una página de panel diferente para los roles /admin o /user</p>
</div>
<div class="listingblock">
<div class="title">Grupo de tabs:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Link from 'next/link'

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    &lt;&gt;
      &lt;nav&gt;
        &lt;Link href="/page-views"&gt;Page Views&lt;/Link&gt;
        &lt;Link href="/visitors"&gt;Visitors&lt;/Link&gt;
      &lt;/nav&gt;
      &lt;div&gt;{children}&lt;/div&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el ejemplo anterior añadimos un layout dentro de un slot para permitir a los usuarios navegar por el slot de forma independiente. Esto es útil para crear tabs.</p>
</div>
<div class="sect4">
<h5 id="_modales">Modales</h5>
<div class="ulist">
<div class="title">Las rutas paralelas se pueden utilizar junto con las rutas de intercepción para crear modales. Esto te permite resolver desafíos comunes al construir modales, como:</div>
<ul>
<li>
<p>Hacer el contenido del modal compartible a través de una URL.</p>
</li>
<li>
<p>Preservar el contexto cuando se actualiza la página, en lugar de cerrar el modal.</p>
</li>
<li>
<p>Cerrar el modal en la navegación hacia atrás en lugar de ir a la ruta anterior.</p>
</li>
<li>
<p>Reabrir el modal en la navegación hacia adelante.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>En el ejemplo de un modal hay varios pasos a seguir:</p>
</div>
<div class="listingblock">
<div class="title">Primero creamos una página con un componente de Login:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { Login } from '@/app/ui/login'

export default function Page() {
  return &lt;Login /&gt;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Dentro del slot @auth, interceptamos la ruta /login actualizando la carpeta /(.)login. Importamos el componente &lt;Modal&gt; y sus hijos en el archivo /(.)login/page.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { Modal } from '@/app/ui/modal'
import { Login } from '@/app/ui/login'

export default function Page() {
  return (
    &lt;Modal&gt;
      &lt;Login /&gt;
    &lt;/Modal&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para abrir el modal, pasamos el slot @auth como una prop al layout principal y lo renderizamos junto con la prop children.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Link from 'next/link'

export default function Layout({
  auth,
  children,
}: {
  auth: React.ReactNode
  children: React.ReactNode
}) {
  return (
    &lt;&gt;
      &lt;nav&gt;
        &lt;Link href="/login"&gt;Open modal&lt;/Link&gt;
      &lt;/nav&gt;
      &lt;div&gt;{auth}&lt;/div&gt;
      &lt;div&gt;{children}&lt;/div&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando el usuario hace clic en el &lt;Link&gt;, el modal se abrirá en lugar de navegar a la página /login. Sin embargo, al actualizar o cargar inicialmente, navegar a /login llevará al usuario a la página principal de inicio de sesión.</p>
</div>
<div class="listingblock">
<div class="title">Para cerrar el modal, puedes utilizar el hook useRouter para navegar a la página anterior. En app/ui/modal.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { useRouter } from 'next/navigation'

export function Modal({ children }: { children: React.ReactNode }) {
  const router = useRouter()

  return (
    &lt;&gt;
      &lt;button
        onClick={() =&gt; {
          router.back()
        }}
      &gt;
        Close modal
      &lt;/button&gt;
      &lt;div&gt;{children}&lt;/div&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando se utiliza el componente Link para navegar lejos de una página que ya no debería renderizar el slot @auth, se utiliza una ruta catch-all que devuelve null.</p>
</div>
<div class="listingblock">
<div class="title">En el modal se usa Link para cerrar el modal y volver a la página anterior. En app/ui/modal.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Link from 'next/link'

export function Modal({ children }: { children: React.ReactNode }) {
  return (
    &lt;&gt;
      &lt;Link href="/"&gt;Close modal&lt;/Link&gt;
      &lt;div&gt;{children}&lt;/div&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">En app/@auth/[&#8230;&#8203;catchAll]/page.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Page() {
  return null
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rutas_de_intercepción">Rutas de intercepción</h3>
<div class="paragraph">
<p>La interceptación de rutas nos permite cargar una ruta desde otra parte de tu aplicación dentro del layout actual. Este paradigma de enrutamiento puede ser útil cuando quieres mostrar el contenido de una ruta sin que el usuario cambie a un contexto diferente.</p>
</div>
<div class="ulist">
<div class="title">Las rutas de intercepción se crean utilizando las reglas:</div>
<ul>
<li>
<p>(.) Para coincidir con segmentos en el mismo nivel</p>
</li>
<li>
<p>(..) Para coincidir con segmentos un nivel por encima</p>
</li>
<li>
<p>(..)(..) Para coincidir con segmentos dos niveles por encima</p>
</li>
<li>
<p>(&#8230;&#8203;) Para coincidir con segmentos desde el directorio raíz de la aplicación</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para interceptar la ruta /settings en app/@team/page.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-file hljs" data-lang="file">app/
├── team
│   └── page.tsx
├── (..)user
│   └── page.js</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_route_handlers">Route Handlers</h3>
<div class="paragraph">
<p>Los Route Handlers son funciones que se utilizan para manejar solicitudes de API en el servidor. Se pueden definir exportando una función predeterminada desde un archivo route.tsx en un segmento de ruta.</p>
</div>
<div class="paragraph">
<p>Los Route Handlers solo están disponibles dentro del directorio app. Son el equivalente de las Rutas de API dentro del directorio de páginas, lo que significa que no es necesario utilizar Rutas de API y Route Handlers juntos.</p>
</div>
<div class="listingblock">
<div class="title">Route Handlers se definen en /app/api/route.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export const dynamic = 'force-dynamic' // defaults to auto
export async function GET(request: Request) {}
export async function POST(request: Request) {}
export async function PUT(request: Request) {}
export async function DELETE(request: Request) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los Route Handlers se pueden anidar dentro del directorio app, al igual que page.js y layout.tsx. Pero no puede haber un archivo route.js en el mismo nivel de segmento de ruta que page.js.</p>
</div>
<div class="paragraph">
<p>Los métodos HTTP compatibles son: GET, POST, PUT, PATCH, DELETE, HEAD y OPTIONS. Si se llama a un método no compatible, Next.js devolverá una respuesta 405 Method Not Allowed.</p>
</div>
<div class="listingblock">
<div class="title">Los Route Handlers se almacenan en caché de forma predeterminada cuando se utiliza el método GET con el objeto Response. En app/items/route.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export async function GET() {
  const res = await fetch('https://data.mongodb-api.com/...', {
    headers: {
      'Content-Type': 'application/json',
      'API-Key': process.env.DATA_API_KEY,
    },
  })
  const data = await res.json()

  return Response.json({ data })
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Puedes optar por no almacenar en caché si:</div>
<ul>
<li>
<p>Usas el objeto Request con el método GET.</p>
</li>
<li>
<p>Usas cualquiera de los otros métodos HTTP.</p>
</li>
<li>
<p>Usas Funciones Dinámicas como cookies y cabeceras.</p>
</li>
<li>
<p>Tienes las Opciones de Configuración de Segmento en modo dinámico.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_middleware">Middleware</h3>
<div class="paragraph">
<p>Un Middleware es una función que se ejecuta antes de que se complete una solicitud. Luego, en función de la solicitud entrante, puedes modificar la respuesta reescribiendo, redirigiendo, modificando las cabeceras de la solicitud o respuesta, o respondiendo directamente. El Middleware se ejecuta antes de que se emparejen el contenido en caché y las rutas.</p>
</div>
<div class="ulist">
<div class="title">Algunos escenarios comunes donde el Middleware es particularmente efectivo incluyen:</div>
<ul>
<li>
<p><strong>Autenticación y Autorización:</strong> Asegúrate de la identidad del usuario y comprueba las cookies de sesión antes de conceder acceso a páginas o rutas de API específicas.</p>
</li>
<li>
<p><strong>Redirecciones en el Servidor:</strong> Redirige a los usuarios a nivel de servidor en función de ciertas condiciones (por ejemplo, localización, rol de usuario).</p>
</li>
<li>
<p><strong>Reescritura de Rutas:</strong> Admite pruebas A/B, lanzamientos de funciones o rutas heredadas reescribiendo dinámicamente rutas a rutas de API o páginas en función de las propiedades de la solicitud.</p>
</li>
<li>
<p><strong>Detección de Bots:</strong> Protege tus recursos detectando y bloqueando el tráfico de bots.</p>
</li>
<li>
<p><strong>Registro y Análisis:</strong> Captura y analiza los datos de la solicitud para obtener información antes de procesarlos por la página o la API.</p>
</li>
<li>
<p><strong>Activación de Funciones:</strong> Habilita o deshabilita funciones dinámicamente para lanzamientos de funciones o pruebas sin problemas.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Para crear un Middleware, exporta una función middleware desde un archivo middleware.tsx</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

// This function can be marked `async` if using `await` inside
export function middleware(request: NextRequest) {
  return NextResponse.redirect(new URL('/home', request.url))
}

// See "Matching Paths" below to learn more
export const config = {
  matcher: '/about/:path*',
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>El Middleware se invocará para cada ruta en tu proyecto. Por lo tanto, es crucial utilizar los matchers para apuntar o excluir con precisión rutas específicas.</p>
</div>
<div class="ulist">
<div class="title">El siguiente es el orden de ejecución:</div>
<ul>
<li>
<p>headers de next.config.tsx</p>
</li>
<li>
<p>redirecciones de next.config.tsx</p>
</li>
<li>
<p>Middleware (redirecciones, reescrituras, etc.)</p>
</li>
<li>
<p>beforeFiles (reescrituras) de next.config.tsx</p>
</li>
<li>
<p>Rutas del sistema de archivos (public/, _next/static/, pages/, app/, etc.)</p>
</li>
<li>
<p>afterFiles (reescrituras) de next.config.tsx</p>
</li>
<li>
<p>Rutas Dinámicas (/blog/[slug])</p>
</li>
<li>
<p>fallback (reescrituras) de next.config.tsx</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_data_fetching">Data Fetching</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Data fetching es una parte fundamental de cualquier aplicación. Next.js proporciona una variedad de formas de obtener datos en tus aplicaciones, incluyendo la obtención de datos en el servidor, en el cliente y en la compilación.</p>
</div>
<div class="ulist">
<div class="title">Hay cuatro formas de obtener datos:</div>
<ul>
<li>
<p>En el servidor, con fetch</p>
</li>
<li>
<p>En el servidor, con bibliotecas de terceros</p>
</li>
<li>
<p>En el cliente, a través de un Route Handler</p>
</li>
<li>
<p>En el cliente, con bibliotecas de terceros.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Next.js extiende la API web fetch nativa para permitirte configurar el comportamiento de almacenamiento en caché y revalidación para cada solicitud de fetch en el servidor. React extiende fetch para memorizar automáticamente las solicitudes de fetch mientras renderiza un árbol de componentes de React.</p>
</div>
<div class="ulist">
<div class="title">Se puede utilizar fetch con async/await en Componentes del Servidor, en Route Handlers y en Acciones del Servidor.</div>
<ul>
<li>
<p>Componentes del Servidor</p>
</li>
<li>
<p>Route Handlers</p>
</li>
<li>
<p>Server Actions.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para obtener datos en un componente del servidor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">async function getData() {
  const res = await fetch('https://api.example.com/...')
  // The return value is *not* serialized
  // You can return Date, Map, Set, etc.

  if (!res.ok) {
    // This will activate the closest `error.js` Error Boundary
    throw new Error('Failed to fetch data')
  }

  return res.json()
}

export default async function Page() {
  const data = await getData()

  return &lt;main&gt;&lt;/main&gt;
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En resumen:</div>
<ul>
<li>
<p>Next.js proporciona funciones útiles que puedes necesitar al obtener datos en Componentes del Servidor, como cookies y cabeceras. Estas funciones harán que la ruta se renderice de forma dinámica, ya que dependen de la información del tiempo de solicitud.</p>
</li>
<li>
<p>En los Route Handlers, las solicitudes de fetch no se memorizan, ya que los Route Handlers no forman parte del árbol de componentes de React.</p>
</li>
<li>
<p>En las Server Actions, las solicitudes de fetch no se almacenan en caché (por defecto, cache: no-store).</p>
</li>
<li>
<p>Para usar async/await en un Componente del Servidor con TypeScript, necesitarás usar TypeScript 5.1.3 o superior y @types/react 18.2.8 o superior.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_server_actions_y_mutations">Server Actions y Mutations</h3>
<div class="paragraph">
<p>Server Actions son funciones asíncronas que se ejecutan en el servidor. Se pueden utilizar en Componentes del Servidor y del Cliente para manejar envíos de formularios y mutaciones de datos en aplicaciones Next.js.</p>
</div>
<div class="paragraph">
<p>Una Server Action se puede definir con la directiva React <strong>"use server"</strong>. Puedes colocar la directiva en la parte superior de una función asíncrona para marcar la función como una Server Action, o en la parte superior de un archivo separado para marcar todas las exportaciones de ese archivo como Server Actions.</p>
</div>
<div class="listingblock">
<div class="title">Los Componentes del Servidor pueden usar la directiva "use server" en el nivel de función o de módulo. Para incrustar una Server Action, añade "use server" en la parte superior del cuerpo de la función:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">// Server Component
export default function Page() {
  // Server Action
  async function create() {
    'use server'

    // ...
  }

  return (
    // ...
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los Componentes del Cliente solo pueden importar acciones que utilicen la directiva "use server" a nivel de módulo. Para llamar a una Server Action en un Componente del Cliente, crea un nuevo archivo y añade la directiva "use server" en la parte superior. Todas las funciones dentro del archivo se marcarán como Server Actions que se pueden reutilizar en Componentes del Cliente y del Servidor.</p>
</div>
<div class="listingblock">
<div class="title">Podemos tener un archivo server-actions.tsx con varias Server Actions:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">// server-actions.tsx
'use server'

export async function create() {
  // ...
}

export async function update() {
  // ...
}

export async function remove() {
  // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">En un Componente del Cliente, se pueden importar y llamar a las Server Actions definidas en server-actions.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">// Client Component
import { create, update, remove } from './server-actions'

export function Button() {
  return (
    // ...
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Puedes pasar una Server Action a un Componente del Cliente como una propiedad:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">// Client Component
&lt;ClientComponent updateItem={updateItem} /&gt;

// client-component.tsx
export default function ClientComponent({ updateItem }) {
  return (
    // ...
  )
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Las Server Actions se pueden invocar utilizando el atributo action en un elemento &lt;form&gt;:</div>
<ul>
<li>
<p>Los Server Components admiten la mejora progresiva de forma predeterminada, lo que significa que el formulario se enviará incluso si JavaScript aún no se ha cargado o está deshabilitado.</p>
</li>
<li>
<p>En los Componentes del Cliente, los formularios que invocan Server Actions encolarán las presentaciones si JavaScript aún no se ha cargado, priorizando la hidratación del cliente.</p>
</li>
<li>
<p>Después de la hidratación, el navegador no se actualiza al enviar el formulario.</p>
</li>
<li>
<p>Las Server Actions no se limitan a &lt;form&gt; y se pueden invocar desde controladores de eventos, useEffect, bibliotecas de terceros y otros elementos de formulario como &lt;button&gt;.</p>
</li>
<li>
<p>Las Server Actions se integran con la arquitectura de almacenamiento en caché y revalidación de Next.js. Cuando se invoca una acción, Next.js puede devolver tanto la interfaz de usuario actualizada como los nuevos datos en una sola ida y vuelta del servidor.</p>
</li>
<li>
<p>Las acciones utilizan el método POST, y solo este método HTTP puede invocarlas.</p>
</li>
<li>
<p>Los argumentos y el valor de retorno de las Server Actions deben ser serializables por React.</p>
</li>
<li>
<p>Las Server Actions son funciones. Esto significa que se pueden reutilizar en cualquier parte de tu aplicación.</p>
</li>
<li>
<p>Las Server Actions heredan el tiempo de ejecución de la página o el layout en el que se utilizan.</p>
</li>
<li>
<p>Las Server Actions heredan la Configuración del Segmento de Ruta de la página o el layout en el que se utilizan, incluidos campos como maxDuration.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_server_actions_con_formularios">Server Actions con Formularios</h4>
<div class="paragraph">
<p>React extiende el elemento HTML &lt;form&gt; para permitir que las Server Actions se invoquen con la propiedad action.</p>
</div>
<div class="paragraph">
<p>Cuando se invoca en un formulario, la acción recibe automáticamente el objeto FormData. No es necesario utilizar React useState para gestionar los campos, en su lugar, se puede extraer los datos utilizando los métodos nativos de FormData.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, para invocar una Server Action en un formulario:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Page() {
  async function createInvoice(formData: FormData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // mutate data
    // revalidate cache
  }

  return &lt;form action={createInvoice}&gt;...&lt;/form&gt;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_usos_comunes_de_data_fetching">Usos comunes de Data Fetching</h4>
<div class="listingblock">
<div class="title">Data Fetching secuencial:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">// ...

async function Playlists({ artistID }: { artistID: string }) {
  // Wait for the playlists
  const playlists = await getArtistPlaylists(artistID)

  return (
    &lt;ul&gt;
      {playlists.map((playlist) =&gt; (
        &lt;li key={playlist.id}&gt;{playlist.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  )
}

export default async function Page({
  params: { username },
}: {
  params: { username: string }
}) {
  // Wait for the artist
  const artist = await getArtist(username)

  return (
    &lt;&gt;
      &lt;h1&gt;{artist.name}&lt;/h1&gt;
      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;Playlists artistID={artist.id} /&gt;
      &lt;/Suspense&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Data Fetching paralelo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Albums from './albums'

async function getArtist(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}`)
  return res.json()
}

async function getArtistAlbums(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`)
  return res.json()
}

export default async function Page({
  params: { username },
}: {
  params: { username: string }
}) {
  // Initiate both requests in parallel
  const artistData = getArtist(username)
  const albumsData = getArtistAlbums(username)

  // Wait for the promises to resolve
  const [artist, albums] = await Promise.all([artistData, albumsData])

  return (
    &lt;&gt;
      &lt;h1&gt;{artist.name}&lt;/h1&gt;
      &lt;Albums list={albums}&gt;&lt;/Albums&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Precarga de datos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { getItem } from '@/utils/get-item'

export const preload = (id: string) =&gt; {
  // void evaluates the given expression and returns undefined
  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void
  void getItem(id)
}
export default async function Item({ id }: { id: string }) {
  const result = await getItem(id)
  // ...
}

import Item, { preload, checkIsAvailable } from '@/components/Item'

export default async function Page({
  params: { id },
}: {
  params: { id: string }
}) {
  // starting loading item data
  preload(id)
  // perform another asynchronous task
  const isAvailable = await checkIsAvailable()

  return isAvailable ? &lt;Item id={id} /&gt; : null
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_renderizado">Renderizado</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_diferencias_entre_client_components_y_server_components_en_next_js">Diferencias entre Client Components y Server Components en Next.js</h3>
<div class="paragraph">
<p>En Next.js, los "client components" y "server components" representan dos paradigmas diferentes para la renderización y manejo de componentes en la aplicación, especialmente relevante en la versión 13 y posteriores, que introducen los Server Components. Aquí te explico las diferencias principales entre ambos:</p>
</div>
<div class="sect3">
<h4 id="_client_components_componentes_del_cliente">Client Components (Componentes del Cliente)</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Ejecución</strong>: Se ejecutan en el navegador del cliente.</p>
</li>
<li>
<p><strong>Interactividad</strong>: Son necesarios para la interactividad en la aplicación. Todo lo relacionado con eventos de usuario (clicks, formularios, etc.) debe manejarse en client components.</p>
</li>
<li>
<p><strong>Estado Local y Efectos</strong>: Utilizan hooks de React como <code>useState</code>, <code>useEffect</code>, etc., que permiten manejar estado local y efectos secundarios.</p>
</li>
<li>
<p><strong>Rendering</strong>: Estos componentes se pueden renderizar inicialmente en el servidor (Server-Side Rendering) o en el cliente (Client-Side Rendering), pero siempre tendrán que ser ejecutados en el navegador para manejar la interactividad.</p>
</li>
<li>
<p><strong>Transporte de JavaScript</strong>: Todo el código de los client components se envía al cliente, lo que puede aumentar el tamaño del bundle y afectar el tiempo de carga de la página.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_server_components_componentes_del_servidor">Server Components (Componentes del Servidor)</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Ejecución</strong>: Se ejecutan en el servidor.</p>
</li>
<li>
<p><strong>Interactividad</strong>: No manejan interactividad directamente. Están pensados principalmente para la lógica de presentación y la generación de HTML.</p>
</li>
<li>
<p><strong>Estado y Efectos</strong>: No utilizan hooks como <code>useState</code> o <code>useEffect</code>. Pueden usar hooks específicos para el servidor como <code>useServerEffect</code> (ficticio para ilustración), pero no pueden manejar interactividad del cliente.</p>
</li>
<li>
<p><strong>Rendering</strong>: Se renderizan completamente en el servidor y el HTML generado se envía al cliente. No se envía JavaScript adicional al cliente para estos componentes, lo que puede reducir el tamaño del bundle y mejorar el rendimiento de la página.</p>
</li>
<li>
<p><strong>Composición</strong>: Pueden incluir y renderizar otros server components y client components. La idea es que los server components gestionen la lógica pesada del servidor y deleguen la interactividad a los client components.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_uso_combinado">Uso Combinado</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Optimización</strong>: Utilizando una combinación de server components para la lógica pesada del servidor y client components para la interactividad, se puede optimizar la carga y el rendimiento de la aplicación.</p>
</li>
<li>
<p><strong>Separación de responsabilidades</strong>: Facilita la separación de responsabilidades, donde los server components se encargan de la generación de contenido estático o dinámico en el servidor y los client components manejan la interacción del usuario.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_básico">Ejemplo Básico</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">// Server Component (MyServerComponent.jsx)
export default function MyServerComponent() {
  const data = fetchDataFromServer(); // Imagina que esta función obtiene datos del servidor
  return (
    &lt;div&gt;
      &lt;h1&gt;Datos del Servidor&lt;/h1&gt;
      &lt;p&gt;{data}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Client Component (MyClientComponent.jsx)
'use client';

import { useState } from 'react';

export default function MyClientComponent() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;h1&gt;Contador&lt;/h1&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Incrementar&lt;/button&gt;
      &lt;p&gt;Cuenta: {count}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. En esta tabla se resumen las diferencias entre roles de Componentes del Servidor y del Cliente:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">¿Qué necesitas hacer?</th>
<th class="tableblock halign-left valign-top">Componente del servidor</th>
<th class="tableblock halign-left valign-top">Componente del cliente</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Obtener datos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Acceder a recursos del backend directamente</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mantener información sensible en el servidor (tokens de acceso, claves API, etc.)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mantener grandes dependencias en el servidor / Reducir JavaScript en el lado del cliente</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Agregar interactividad y listeners de eventos (onClick(), onChange(), etc.)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usar Estado y Efectos de Ciclo de Vida (useState(), useReducer(), useEffect(), etc.)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usar APIs exclusivas del navegador</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usar hooks personalizados que dependan del estado, efectos, o APIs exclusivas del navegador</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usar componentes de clase de React</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_entornos_de_ejecución_de_client_components_y_server_components">Entornos de ejecución de Client Components y Server Components</h3>
<div class="sect3">
<h4 id="_node_js_runtime">Node.js Runtime</h4>
<div class="paragraph">
<p>EL uso de Node.js te da acceso a todas las API de Node.js y a todos los paquetes npm que dependen de ellas. Sin embargo, no es tan rápido de iniciar como las rutas que utilizan el tiempo de ejecución de Edge.</p>
</div>
<div class="paragraph">
<p>El despliegue de una aplicación Next.js en un servidor Node.js requerirá gestionar, escalar y configurar tu infraestructura.</p>
</div>
</div>
<div class="sect3">
<h4 id="_edge_runtime">Edge Runtime</h4>
<div class="paragraph">
<p>En Next.js, el ligero entorno de ejecución de Edge es un subconjunto de las API de Node.js disponibles.</p>
</div>
<div class="paragraph">
<p>El entorno de ejecución de Edge es ideal si necesitas entregar contenido dinámico y personalizado con baja latencia utilizando funciones pequeñas y simples. La velocidad del entorno de ejecución de Edge se debe a su uso mínimo de recursos, pero esto puede ser limitante en muchos escenarios.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, el código ejecutado en el entorno de ejecución de Edge en algunas plataformas no puede exceder entre 1 MB y 4 MB, este límite incluye paquetes importados, fuentes y archivos, y variará dependiendo de tu infraestructura de despliegue. Además, el entorno de ejecución de Edge no soporta todas las API de Node.js, lo que significa que algunos paquetes npm pueden no funcionar. Por ejemplo, "Module not found: Can&#8217;t resolve 'fs'" u otros errores similares. Recomendamos utilizar el entorno de ejecución de Node.js si necesitas utilizar estas API o paquetes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_serverless_node_js">Serverless Node.js</h4>
<div class="paragraph">
<p>EL modelo Serverless es ideal si necesitas una solución escalable que pueda manejar cargas computacionales más complejas que el tiempo de ejecución de Edge.</p>
</div>
<div class="paragraph">
<p>La desventaja en comparación con las rutas que utilizan el Edge es que puede tardar cientos de milisegundos en arrancar las funciones Serverless antes de que comiencen a procesar las solicitudes. Dependiendo de la cantidad de tráfico que reciba tu sitio, esto podría ser una ocurrencia frecuente ya que las funciones no están frecuentemente "calientes".</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Característica</th>
<th class="tableblock halign-left valign-top">Node</th>
<th class="tableblock halign-left valign-top">Serverless</th>
<th class="tableblock halign-left valign-top">Edge</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inicio en frío</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Normal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bajo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transmisión HTTP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Todo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Todo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fetch</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Escalabilidad</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alta</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Máxima</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Seguridad</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Normal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alta</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alta</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Latencia</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Normal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Baja</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mínima</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Paquetes npm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Todo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Todo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Un subconjunto más pequeño</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Renderizado estático</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Renderizado dinámico</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidación de datos con fetch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Para establecer un entorno de ejecución, en page.tsx o layout.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export const runtime = 'edge' // 'nodejs' (default) | 'edge'</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cache">Cache</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Next.js mejora el rendimiento de la aplicación y reduce costes al almacenar en caché el trabajo de renderizado y las solicitudes de datos. Next.js proporciona una variedad de mecanismos de almacenamiento en caché para ayudarte a gestionar el almacenamiento en caché de tus rutas y datos de forma eficiente.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Aquí hay una descripción general de los diferentes mecanismos de almacenamiento en caché y su propósito:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Mecanismo</th>
<th class="tableblock halign-left valign-top">Qué</th>
<th class="tableblock halign-left valign-top">Dónde</th>
<th class="tableblock halign-left valign-top">Propósito</th>
<th class="tableblock halign-left valign-top">Duración</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Request Memoization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Valores de retorno de funciones</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servidor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reutilizar datos en un árbol de Componentes de React</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ciclo de vida de la solicitud</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data Cache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Datos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servidor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Almacenar datos a través de solicitudes de usuarios y despliegues</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Persistente (puede ser revalidado)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Full Route Cache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTML y carga útil de RSC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servidor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reducir el costo de renderizado y mejorar el rendimiento</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Persistente (puede ser revalidado)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Router Cache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Carga útil de RSC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cliente</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reducir las solicitudes al servidor en la navegación</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sesión del usuario o basado en tiempo</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Por defecto, Next.js almacenará en caché tanto como sea posible para mejorar el rendimiento y reducir costes. Esto significa que las rutas se renderizan estáticamente y las solicitudes de datos se almacenan en caché a menos que optes por no hacerlo.</p>
</div>
<div class="sect2">
<h3 id="_request_memoization">Request Memoization</h3>
<div class="paragraph">
<p>React extiende la API fetch para memorizar automáticamente las solicitudes que tienen la misma URL y opciones. Esto significa que puedes llamar a una función fetch para los mismos datos en múltiples lugares en un árbol de componentes de React y solo ejecutarla una vez.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, si hay que utilizar los mismos datos en una ruta (por ejemplo, en un Layout, Page y múltiples componentes), no es necesario obtener los datos en la parte superior del árbol y reenviar props entre componentes. En su lugar, puedes obtener los datos en los componentes que los necesitan sin preocuparte por las implicaciones de rendimiento de hacer múltiples solicitudes a través de la red para los mismos datos.</p>
</div>
<div class="listingblock">
<div class="title">Ejemlo de Request Memoization:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">async function getItem() {
  // The `fetch` function is automatically memoized and the result
  // is cached
  const res = await fetch('https://.../item/1')
  return res.json()
}

// This function is called twice, but only executed the first time
const item = await getItem() // cache MISS

// The second call could be anywhere in your route
const item = await getItem() // cache HIT</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Comportamiento de Request Memoization:</div>
<ul>
<li>
<p>Mientras se renderiza una ruta, la primera vez que se llama a una solicitud en particular, su resultado no estará en memoria y será un cache MISS.</p>
</li>
<li>
<p>Por lo tanto, la función se ejecutará y los datos se obtendrán de la fuente externa, y el resultado se almacenará en memoria.</p>
</li>
<li>
<p>Las llamadas de función subsiguientes de la solicitud en el mismo pase de renderizado serán un cache HIT, y los datos se devolverán de la memoria sin ejecutar la función.</p>
</li>
<li>
<p>Una vez que se ha renderizado la ruta y se ha completado el pase de renderizado, la memoria se "restablece" y todas las entradas de memorización de solicitud se borran.</p>
</li>
<li>
<p>La memorización de solicitudes es una característica de React, no de Next.js. Se incluye aquí para mostrar cómo interactúa con los otros mecanismos de almacenamiento en caché.</p>
</li>
<li>
<p>La memorización solo se aplica al método GET en las solicitudes de fetch.</p>
</li>
<li>
<p>Se aplica a las solicitudes de fetch en generateMetadata, generateStaticParams, Layouts, Pages y otros Componentes del Servidor.</p>
</li>
<li>
<p>No se aplica a las solicitudes de fetch en Route Handlers, ya que no forman parte del árbol de componentes de React.</p>
</li>
<li>
<p>Para casos en los que fetch no es adecuado (por ejemplo, algunos clientes de bases de datos, clientes de CMS o clientes de GraphQL), puedes utilizar la función de caché de React para memorizar funciones.</p>
</li>
<li>
<p>La memoria caché dura toda la vida de una solicitud de servidor hasta que el árbol de componentes de React haya terminado de renderizarse.</p>
</li>
<li>
<p>Dado que la memorización no se comparte entre las solicitudes del servidor y solo se aplica durante el renderizado, no es necesario revalidarla.</p>
</li>
<li>
<p>La memorización sólo se aplica al método GET en las solicitudes de fetch, otros métodos, como POST y DELETE, no se memorizan. Este comportamiento predeterminado es una optimización de React y no recomendamos optar por no utilizarlo.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Para gestionar solicitudes individuales, puedes utilizar la propiedad signal de AbortController. Sin embargo, esto no excluirá las solicitudes de la memorización, sino que abortará las solicitudes en curso.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">const { signal } = new AbortController()
fetch(url, { signal })</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_data_cache">Data Cache</h3>
<div class="paragraph">
<p>Next.js tiene una caché de datos integrada que persiste el resultado de las solicitudes de datos a través de las solicitudes entrantes al servidor y los despliegues. Esto es posible porque Next.js extiende la API fetch nativa para permitir que cada solicitud en el servidor establezca su propia semántica de almacenamiento en caché persistente.</p>
</div>
<div class="paragraph">
<p>En el navegador, la opción cache de fetch indica cómo una solicitud interactuará con la caché HTTP del navegador, en Next.js, la opción cache indica cómo una solicitud en el servidor interactuará con la caché de datos del servidor.</p>
</div>
<div class="paragraph">
<p>Por defecto, las solicitudes de datos que utilizan fetch se almacenan en caché. Puedes utilizar las opciones cache y next.revalidate de fetch para configurar el comportamiento de almacenamiento en caché.</p>
</div>
<div class="ulist">
<div class="title">Cómo funciona Data Cache:</div>
<ul>
<li>
<p>La primera vez que se llama a una solicitud de fetch durante el renderizado, Next.js comprueba la Data Cache en busca de una respuesta en caché.</p>
</li>
<li>
<p>Si se encuentra una respuesta en caché, se devuelve inmediatamente y se memoriza.</p>
</li>
<li>
<p>Si no se encuentra una respuesta en caché, se realiza la solicitud al origen de datos, el resultado se almacena en la Data Cache y se memoriza.</p>
</li>
<li>
<p>Para los datos sin caché (por ejemplo, { cache: 'no-store' }), el resultado siempre se obtiene del origen de datos y se memoriza.</p>
</li>
<li>
<p>Ya sea que los datos estén en caché o no, las solicitudes siempre se memorizan para evitar hacer solicitudes duplicadas por los mismos datos durante un pase de renderizado de React.</p>
</li>
<li>
<p>Data Cache es persistente a través de las solicitudes entrantes y los despliegues a menos que revalide o opte por no hacerlo.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Los datos en caché se pueden revalidar de dos maneras, con:</div>
<ul>
<li>
<p><strong>Revalidación basada en el tiempo:</strong> Revalida los datos después de que haya pasado cierta cantidad de tiempo y se haga una nueva solicitud. Esto es útil para datos que cambian con poca frecuencia y la frescura no es tan crítica.</p>
</li>
<li>
<p><strong>Revalidación bajo demanda:</strong> Revalida los datos en función de un evento (por ejemplo, envío de formulario). La revalidación bajo demanda puede utilizar un enfoque basado en etiquetas o en rutas para revalidar grupos de datos a la vez. Esto es útil cuando quieres asegurarte de que los datos más recientes se muestren lo antes posible (por ejemplo, cuando se actualiza el contenido de tu CMS sin cabeza).</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Para revalidar los datos en un intervalo de tiempo, puedes utilizar la opción next.revalidate de fetch para establecer la vida útil de la caché de un recurso (en segundos).</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">// Revalidate at most every hour
fetch('https://...', { next: { revalidate: 3600 } })</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Cómo funciona la revalidación basada en el tiempo:</div>
<ul>
<li>
<p>La primera vez que se llama a una solicitud de fetch con revalidate, los datos se obtendrán de la fuente de datos externa y se almacenarán en la Data Cache.</p>
</li>
<li>
<p>Cualquier solicitud que se realice dentro del intervalo de tiempo especificado (por ejemplo, 60 segundos) devolverá los datos en caché.</p>
</li>
<li>
<p>Después del intervalo de tiempo, la siguiente solicitud seguirá devolviendo los datos en caché (ahora obsoletos).</p>
<div class="ulist">
<ul>
<li>
<p>Next.js activará una revalidación de los datos en segundo plano.</p>
</li>
<li>
<p>Una vez que los datos se obtengan correctamente, Next.js actualizará la Data Cache con los datos frescos.</p>
</li>
<li>
<p>Si la revalidación en segundo plano falla, los datos anteriores se mantendrán sin cambios.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_full_route_cache">Full Route Cache</h3>
<div class="paragraph">
<p>Next.js renderiza y almacena en caché automáticamente las rutas en el tiempo de construcción. Esta es una optimización que te permite servir la ruta en caché en lugar de renderizar en el servidor para cada solicitud, lo que resulta en cargas de página más rápidas.</p>
</div>
<div class="paragraph">
<p>Para entender cómo funciona la Full Route Cache, es útil ver cómo React maneja el renderizado y cómo Next.js almacena en caché el resultado.</p>
</div>
<div class="sect3">
<h4 id="_renderizado_en_react_en_el_servidor">Renderizado en React en el Servidor</h4>
<div class="paragraph">
<p>En el servidor, Next.js utiliza las API de React para orquestar el renderizado. El trabajo de renderizado se divide en fragmentos: por segmentos de rutas individuales y límites de Suspense.</p>
</div>
<div class="ulist">
<div class="title">Cada fragmento se renderiza en dos pasos:</div>
<ul>
<li>
<p>React renderiza los Componentes del Servidor en un formato de datos especial, optimizado para la transmisión, llamado el Payload de Componente del Servidor de React.</p>
</li>
<li>
<p>Next.js utiliza el Payload de Componente del Servidor de React e instrucciones de JavaScript de Componente del Cliente para renderizar HTML en el servidor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esto significa que no tenemos que esperar a que todo se renderice antes de almacenar en caché el trabajo o enviar una respuesta. En su lugar, podemos transmitir una respuesta a medida que se completa el trabajo.</p>
</div>
<div class="paragraph">
<p>Qué es el Payload de Componente del Servidor de React?</p>
</div>
<div class="paragraph">
<p>El Payload de Componente del Servidor de React es una representación binaria compacta del árbol de Componentes del Servidor de React renderizado. Se utiliza por React en el cliente para actualizar el DOM del navegador.</p>
</div>
<div class="ulist">
<div class="title">El Payload de Componente del Servidor de React contiene:</div>
<ul>
<li>
<p>El resultado renderizado de los Componentes del Servidor</p>
</li>
<li>
<p>Marcadores de posición para dónde deben renderizarse los Componentes del Cliente y referencias a sus archivos JavaScript</p>
</li>
<li>
<p>Cualquier prop que se pase de un Componente del Servidor a un Componente del Cliente</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_almacenamiento_en_caché_de_next_js_en_el_servidor_caché_de_ruta_completa">Almacenamiento en caché de Next.js en el Servidor (Caché de Ruta Completa)</h4>
<div class="paragraph">
<p>El comportamiento predeterminado de Next.js es almacenar en caché el resultado renderizado (Payload de Componente del Servidor de React y HTML) de una ruta en el servidor. Esto se aplica a las rutas renderizadas estáticamente en el tiempo de construcción, o durante la revalidación.</p>
</div>
<div class="sect4">
<h5 id="_react_hydration_y_reconciliation_en_el_client">React Hydration y Reconciliation en el Client</h5>
<div class="ulist">
<div class="title">En el momento de la solicitud, en el cliente:</div>
<ul>
<li>
<p>El HTML se utiliza para mostrar inmediatamente una vista previa inicial rápida no interactiva de los Componentes del Cliente y del Servidor.</p>
</li>
<li>
<p>El Payload de Componente del Servidor de React se utiliza para conciliar los árboles de Componentes del Cliente y del Servidor renderizados, y actualizar el DOM.</p>
</li>
<li>
<p>Las instrucciones de JavaScript se utilizan para hidratar. Los Componentes del Cliente y se utilizan para hacer que la aplicación sea interactiva.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_next_js_caching_en_el_cliente_router_cache">Next.js Caching en el cliente (Router Cache)</h5>
<div class="paragraph">
<p>El Payload de Componente del Servidor de React se almacena en la caché del enrutador del lado del cliente, una caché en memoria separada, dividida por segmento de ruta individual. Esta caché del enrutador se utiliza para mejorar la experiencia de navegación almacenando las rutas visitadas anteriormente y precargando las rutas futuras.</p>
</div>
</div>
<div class="sect4">
<h5 id="_navegaciones_posteriores">Navegaciones posteriores</h5>
<div class="paragraph">
<p>En las navegaciones posteriores o durante la precarga, Next.js comprobará si el Payload de Componente del Servidor de React está almacenado en la caché del enrutador. Si es así, omitirá enviar una nueva solicitud al servidor.</p>
</div>
<div class="paragraph">
<p>Si los segmentos de ruta no están en la caché, Next.js obtendrá el Payload de Componente del Servidor de React del servidor y llenará la caché del enrutador en el cliente.</p>
</div>
</div>
<div class="sect4">
<h5 id="_renderizado_estático_y_dinámico">Renderizado Estático y Dinámico</h5>
<div class="paragraph">
<p>Cuando la ruta está en caché o no en el tiempo de construcción depende de si se renderiza estática o dinámicamente. Las rutas estáticas se almacenan en caché de forma predeterminada, mientras que las rutas dinámicas se renderizan en el momento de la solicitud y no se almacenan en caché.</p>
</div>
<div class="paragraph">
<p>Por defecto, la Caché de Ruta Completa es persistente. Esto significa que la salida del renderizado se almacena en caché a través de las solicitudes de los usuarios.</p>
</div>
<div class="ulist">
<div class="title">Hay dos formas de invalidar la Caché de Ruta Completa:</div>
<ul>
<li>
<p>Revalidación de Datos: Revalidar la Caché de Datos, a su vez invalidará la Caché del Enrutador al volver a renderizar componentes en el servidor y almacenar en caché la nueva salida de renderizado.</p>
</li>
<li>
<p>Redespliegue: A diferencia de la Caché de Datos, que persiste a través de los despliegues, la Caché de Ruta Completa se borra en los nuevos despliegues.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Puedes optar por no utilizar la Caché de Ruta Completa, o en otras palabras, renderizar dinámicamente componentes para cada solicitud entrante, mediante:</div>
<ul>
<li>
<p>Usando una función dinámica: Esto optará por no utilizar la Caché de Ruta Completa y renderizarla dinámicamente en el momento de la solicitud. La Caché de Datos todavía se puede utilizar.</p>
</li>
<li>
<p>Usando las opciones de configuración de segmento de ruta dynamic = 'force-dynamic' o revalidate = 0: Esto omitirá la Caché de Ruta Completa y la Caché de Datos. Significa que los componentes se renderizarán y los datos se obtendrán en cada solicitud entrante al servidor. La Caché del Enrutador seguirá aplicándose ya que es una caché del lado del cliente.</p>
</li>
<li>
<p>Optar por no utilizar la Caché de Datos: Si una ruta tiene una solicitud de fetch que no está en caché, esto optará por no utilizar la Caché de Ruta Completa. Los datos para la solicitud de fetch específica se obtendrán para cada solicitud entrante. Otras solicitudes de fetch que no opten por no almacenar en caché seguirán almacenadas en la Caché de Datos. Esto permite una combinación de datos en caché y no en caché.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_router_cache">Router Cache</h3>
<div class="paragraph">
<p>Next.js tiene una caché en memoria del lado del cliente que almacena el Payload de Componente del Servidor de React, dividido por segmentos de ruta individuales, durante la duración de una sesión de usuario. Esto se llama la Caché del Enrutador.</p>
</div>
<div class="paragraph">
<p>Cuando un usuario navega entre rutas, Next.js almacena en caché los segmentos de ruta visitados y precarga las rutas a las que es probable que navegue el usuario (basándose en los componentes &lt;Link&gt; en su viewport).</p>
</div>
<div class="ulist">
<div class="title">Esto resulta en una experiencia de navegación mejorada para el usuario:</div>
<ul>
<li>
<p>Navegación instantánea hacia atrás/adelante porque las rutas visitadas están en caché y navegación rápida a nuevas rutas debido a la precarga y el renderizado parcial.</p>
</li>
<li>
<p>Sin recarga de página completa entre las navegaciones, y el estado de React y el estado del navegador se conservan.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">La diferencia entre la Caché del Enrutador y la Caché de Ruta Completa:</div>
<ul>
<li>
<p>El Router Cache almacena temporalmente el Payload de Componente del Servidor de React en el navegador durante la duración de una sesión de usuario, mientras que la Caché de Ruta Completa almacena persistentemente el Payload de Componente del Servidor de React y el HTML en el servidor a través de múltiples solicitudes de usuario.</p>
</li>
<li>
<p>Mientras que la Caché de Ruta Completa solo almacena en caché rutas renderizadas estáticamente, la Caché del Enrutador se aplica tanto a rutas renderizadas estática como dinámicamente.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Dos factores determinan cuánto tiempo dura la caché del enrutador:</div>
<ul>
<li>
<p>Sesión: La caché persiste a través de la navegación. Sin embargo, se borra al refrescar la página.</p>
</li>
<li>
<p>Periodo de Invalidez Automática: La caché de un segmento individual se invalida automáticamente después de un tiempo específico. La duración depende de cómo se haya precargado el recurso:</p>
<div class="ulist">
<ul>
<li>
<p>Full Prefetching: (prefetch={true} o router.prefetch): 5 minutos</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Hay dos formas de invalidar la Caché del Enrutador:</div>
<ul>
<li>
<p>En una Acción del Servidor:</p>
<div class="ulist">
<ul>
<li>
<p>Revalidar datos bajo demanda por ruta con (revalidatePath) o por etiqueta de caché con (revalidateTag)</p>
</li>
<li>
<p>Usar cookies.set o cookies.delete invalida la Caché del Enrutador para evitar que las rutas que utilizan cookies se vuelvan obsoletas (por ejemplo, autenticación).</p>
</li>
</ul>
</div>
</li>
<li>
<p>Llamar a router.refresh invalidará la Caché del Enrutador y hará una nueva solicitud al servidor para la ruta actual.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>No es posible optar por no utilizar la Caché del Router. Sin embargo, puedes invalidarla llamando a router.refresh, revalidatePath o revalidateTag (ver arriba). Esto limpiará la caché y hará una nueva solicitud al servidor, asegurando que se muestren los datos más recientes.</p>
</div>
<div class="paragraph">
<p>Es posible optar por no precargar configurando la propiedad prefetch del componente &lt;Link&gt; en false. Sin embargo, esto seguirá almacenando temporalmente los segmentos de ruta durante 30 segundos para permitir la navegación instantánea entre segmentos anidados, como las barras de pestañas, o la navegación hacia atrás y hacia adelante. Las rutas visitadas seguirán en caché.</p>
</div>
<div class="ulist">
<div class="title">Interacciones de Caché</div>
<ul>
<li>
<p><strong>Data Cache y Full Route Cache</strong></p>
<div class="ulist">
<ul>
<li>
<p>Revalidar u optar por no utilizar la Caché de Datos invalidará la Caché de Ruta Completa, ya que la salida del renderizado depende de los datos.</p>
</li>
<li>
<p>Invalidar u optar por no utilizar la Caché de Ruta Completa no afecta a la Caché de Datos. Puedes renderizar dinámicamente una ruta que tenga datos en caché y no en caché. Esto es útil cuando la mayor parte de tu página utiliza datos en caché, pero tienes algunos componentes que dependen de datos que deben obtenerse en el momento de la solicitud. Puedes renderizar dinámicamente sin preocuparte por el impacto en el rendimiento de volver a obtener todos los datos.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Data Cache y Caché del Enrutador del lado del cliente</strong></p>
<div class="ulist">
<ul>
<li>
<p>Revalidar la Caché de Datos en un Route Handler no invalidará inmediatamente la Caché del Enrutador, ya que el Route Handler no está vinculado a una ruta específica. Esto significa que la Caché del Enrutador seguirá sirviendo el payload anterior hasta una recarga dura, o</p>
</li>
<li>
<p>Para invalidar inmediatamente la Caché de Datos y la Caché del Enrutador, puedes utilizar revalidatePath o revalidateTag en una Acción del Servidor.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. La siguiente tabla proporciona una visión general de cómo diferentes API de Next.js afectan al almacenamiento en caché:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">API</th>
<th class="tableblock halign-left valign-top">Caché del Router Completo</th>
<th class="tableblock halign-left valign-top">Caché de Datos</th>
<th class="tableblock halign-left valign-top">Caché de React</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;Link prefetch&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caché</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">router.prefetch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caché</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">router.refresh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fetch</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caché</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caché</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fetch options.cache</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caché o No utilizar</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fetch options.next.revalidate</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fetch options.next.tags</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caché</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caché</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">revalidateTag</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar (Acción del Servidor)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">revalidatePath</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar (Acción del Servidor)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">const revalidate</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar o No utilizar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar o No utilizar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">const dynamic</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caché o No utilizar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caché o No utilizar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cookies</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revalidar (Acción del Servidor)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No utilizar</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">headers, searchParams</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No utilizar</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">generateStaticParams</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caché</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">React.cache</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caché</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">unstable_cache</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_optimización">Optimización</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_images">Images</h3>
<div class="ulist">
<div class="title">El componente Image de Next.js extiende el elemento HTML &lt;img&gt; con funciones para la optimización automática de imágenes:</div>
<ul>
<li>
<p><strong>Optimización del tamaño:</strong> Sirve automáticamente imágenes del tamaño correcto para cada dispositivo, utilizando formatos de imagen modernos como WebP y AVIF.</p>
</li>
<li>
<p><strong>Estabilidad visual:</strong> Evita automáticamente el cambio de layout cuando las imágenes se están cargando.</p>
</li>
<li>
<p><strong>Cargas de página más rápidas:</strong> Las imágenes solo se cargan cuando entran en el viewport utilizando la carga perezosa nativa del navegador, con marcadores de posición opcionales de desenfoque.</p>
</li>
<li>
<p><strong>Flexibilidad de assets:</strong> Cambio de tamaño de imágenes bajo demanda, incluso para imágenes almacenadas en servidores remotos.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de Image para imagen local:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Image from 'next/image'
import profilePic from './me.png'

export default function Page() {
  return (
    &lt;Image
      src={profilePic}
      alt="Picture of the author"
      // width={500} automatically provided
      // height={500} automatically provided
      // blurDataURL="data:..." automatically provided
      // placeholder="blur" // Optional blur-up while loading
    /&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el ejemplo anterior, se proporciona una URL parcial ("/me.png") para una imagen local. Esto es posible gracias a la arquitectura de los <strong>loaders</strong>.</p>
</div>
<div class="paragraph">
<p>Un loader es una función que genera las URL para tu imagen. Modifica el src proporcionado y genera múltiples URL para solicitar la imagen en diferentes tamaños. Estas múltiples URL se utilizan en la generación automática de srcset, para que los visitantes de tu sitio reciban una imagen del tamaño adecuado para su viewport.</p>
</div>
<div class="paragraph">
<p>El loader predeterminado para las aplicaciones de Next.js utiliza la API de optimización de imágenes integrada, que optimiza imágenes desde cualquier lugar de la web, y luego las sirve directamente desde el servidor web de Next.js. Si deseas servir tus imágenes directamente desde un CDN o un servidor de imágenes, puedes escribir tu propia función de loader con unas pocas líneas de JavaScript.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de Image para imagen remota:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Image from 'next/image'

export default function Page() {
  return (
    &lt;Image
      src="https://s3.amazonaws.com/my-bucket/profile.png"
      alt="Picture of the author"
      width={500}
      height={500}
      // blurDataURL="data:..." automatically provided
      // placeholder="blur" // Optional blur-up while loading
    /&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para permitir de forma segura la optimización de imágenes, define una lista de patrones de URL admitidos en next.config.tsx. Sé lo más específico posible para evitar un uso malintencionado.</p>
</div>
<div class="listingblock">
<div class="title">Por ejemplo, la siguiente configuración solo permitirá imágenes de un bucket específico de AWS S3, en next.config.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 's3.amazonaws.com',
        port: '',
        pathname: '/my-bucket/**',
      },
    ],
  },
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_priority">Priority</h4>
<div class="paragraph">
<p>Deberías añadir la propiedad priority a la imagen que será el elemento <strong>Largest Contentful Paint</strong> (LCP) para cada página. De esta forma, Next.js puede priorizar especialmente la imagen para su carga (por ejemplo, a través de etiquetas de precarga o pistas de prioridad), lo que conlleva un impulso significativo en el LCP.</p>
</div>
<div class="paragraph">
<p>El elemento LCP suele ser la imagen más grande o el bloque de texto visible dentro del viewport de la página. Cuando ejecutas next dev, verás una advertencia en la consola si el elemento LCP es una &lt;Image&gt; sin la propiedad priority.</p>
</div>
<div class="listingblock">
<div class="title">Una vez que hayas identificado la imagen LCP, puedes añadir la propiedad de la siguiente forma:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Image from 'next/image'
import profilePic from '../public/me.png'

export default function Page() {
  return &lt;Image src={profilePic} alt="Picture of the author" priority /&gt;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_image_sizing">Image sizing</h4>
<div class="paragraph">
<p>Una de las formas más comunes en que las imágenes afectan al rendimiento es a través del cambio de layout, donde la imagen empuja a otros elementos alrededor de la página mientras se carga. Este problema de rendimiento es tan molesto para los usuarios que tiene su propio Core Web Vital, llamado Cambio de layout Acumulativo. La forma de evitar los cambios de layout basados en imágenes es siempre dimensionar tus imágenes. Esto permite al navegador reservar exactamente el espacio suficiente para la imagen antes de que se cargue.</p>
</div>
<div class="ulist">
<div class="title">Porque next/image está diseñado para garantizar buenos resultados de rendimiento, no se puede utilizar de una manera que contribuya al cambio de layout, y debe dimensionarse de una de las tres formas:</div>
<ul>
<li>
<p>Automáticamente, utilizando una importación estática</p>
</li>
<li>
<p>Explícitamente, incluyendo una propiedad de ancho y alto</p>
</li>
<li>
<p>Implícitamente, utilizando fill que hace que la imagen se expanda para llenar su elemento padre.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_estilos">Estilos</h4>
<div class="paragraph">
<p>Usar estilos en el componente Image es similar a usar estilos en un elemento &lt;img&gt; normal, pero hay algunas pautas a tener en cuenta:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Usa className o style, no styled-jsx.</p>
<div class="ulist">
<ul>
<li>
<p>En la mayoría de los casos, recomendamos usar la propiedad className. Esto puede ser un módulo CSS importado, una hoja de estilos global, etc.</p>
</li>
<li>
<p>También puedes usar la propiedad style para asignar estilos en línea.</p>
</li>
<li>
<p>No puedes usar styled-jsx porque está limitado al componente actual (a menos que marques el estilo como global).</p>
</li>
</ul>
</div>
</li>
<li>
<p>Cuando se usa fill, el elemento padre debe tener position: relative</p>
<div class="ulist">
<ul>
<li>
<p>Esto es necesario para el renderizado adecuado del elemento de imagen en ese modo de layout.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Cuando se usa fill, el elemento padre debe tener display: block</p>
<div class="ulist">
<ul>
<li>
<p>Esto es lo predeterminado para los elementos &lt;div&gt; pero debe especificarse de otra manera.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de estilos en Image:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Image from 'next/image'
import mountains from '../public/mountains.jpg'

export default function Responsive() {
  return (
    &lt;div style={{ display: 'flex', flexDirection: 'column' }}&gt;
      &lt;Image
        alt="Mountains"
        // Importing an image will
        // automatically set the width and height
        src={mountains}
        sizes="100vw"
        // Make the image display full width
        style={{
          width: '100%',
          height: 'auto',
        }}
      /&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de fill en Image:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Image from 'next/image'
import mountains from '../public/mountains.jpg'

export default function Fill() {
  return (
    &lt;div
      style={{
        display: 'grid',
        gridGap: '8px',
        gridTemplateColumns: 'repeat(auto-fit, minmax(400px, auto))',
      }}
    &gt;
      &lt;div style={{ position: 'relative', height: '400px' }}&gt;
        &lt;Image
          alt="Mountains"
          src={mountains}
          fill
          sizes="(min-width: 808px) 50vw, 100vw"
          style={{
            objectFit: 'cover', // cover, contain, none
          }}
        /&gt;
      &lt;/div&gt;
      {/* And more images in the grid... */}
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de imagen de fondo con Image:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Image from 'next/image'
import mountains from '../public/mountains.jpg'

export default function Background() {
  return (
    &lt;Image
      alt="Mountains"
      src={mountains}
      placeholder="blur"
      quality={100}
      fill
      sizes="100vw"
      style={{
        objectFit: 'cover',
      }}
    /&gt;
  )
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_video">Video</h3>
<div class="paragraph">
<p>Los videos se pueden incrustar en la página utilizando la etiqueta HTML &lt;video&gt; para archivos de video directos y &lt;iframe&gt; para videos alojados en plataformas externas.</p>
</div>
<div class="sect3">
<h4 id="_video_2">&lt;video&gt;</h4>
<div class="paragraph">
<p>El elemento HTML &lt;video&gt; puede incrustar contenido de video autohospedado o servido directamente, permitiendo un control total sobre la reproducción y la apariencia.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de &lt;video&gt;:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export function Video() {
  return (
    &lt;video width="320" height="240" controls preload="none"&gt;
      &lt;source src="/path/to/video.mp4" type="video/mp4" /&gt;
      &lt;track
        src="/path/to/captions.vtt"
        kind="subtitles"
        srcLang="en"
        label="English"
      /&gt;
      Your browser does not support the video tag.
    &lt;/video&gt;
  )
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. Tabla de tags de &lt;video&gt;:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Atributo</th>
<th class="tableblock halign-left valign-top">Descripción</th>
<th class="tableblock halign-left valign-top">Valor de Ejemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Especifica la fuente del archivo de video.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;video src="/path/to/video.mp4" /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">width</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Establece el ancho del reproductor de video.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;video width="320" /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">height</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Establece la altura del reproductor de video.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;video height="240" /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">controls</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Si está presente, muestra el conjunto predeterminado de controles de reproducción.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;video controls /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">autoPlay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comienza a reproducir el video automáticamente cuando se carga la página. Nota: Las políticas de reproducción automática varían entre navegadores.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;video autoPlay /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">loop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reproduce el video en bucle.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;video loop /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">muted</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Silencia el audio por defecto. A menudo se usa con autoPlay.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;video muted /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">preload</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Especifica cómo se precarga el video. Valores: none, metadata, auto.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;video preload="none" /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">playsInline</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Habilita la reproducción en línea en dispositivos iOS, a menudo necesario para que la reproducción automática funcione en Safari de iOS.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;video playsInline /&gt;</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<div class="title">Buenas prácticas para el uso de &lt;video&gt;:</div>
<ul>
<li>
<p>Contenido de Respaldo: Al utilizar la etiqueta &lt;video&gt;, incluye contenido de respaldo dentro de la etiqueta para los navegadores que no admiten la reproducción de video.</p>
</li>
<li>
<p>Subtítulos o Leyendas: Incluye subtítulos o leyendas para los usuarios sordos o con problemas de audición. Utiliza la etiqueta &lt;track&gt; con tus elementos &lt;video&gt; para especificar las fuentes de archivos de subtítulos.</p>
</li>
<li>
<p>Controles Accesibles: Se recomiendan los controles de video HTML5 estándar para la navegación con teclado y la compatibilidad con lectores de pantalla. Para necesidades avanzadas, considera reproductores de terceros como react-player o video.js, que ofrecen controles accesibles y una experiencia de navegador consistente.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_iframe">&lt;iframe&gt;</h4>
<div class="paragraph">
<p>El elemento HTML &lt;iframe&gt; te permite incrustar videos de plataformas externas como YouTube o Vimeo.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de &lt;iframe&gt;:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default function Page() {
  return (
    &lt;iframe
      src="https://www.youtube.com/watch?v=gfU1iZnjRZM"
      frameborder="0"
      allowfullscreen
    /&gt;
  )
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. Tabla de tags de &lt;iframe&gt;:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Atributo</th>
<th class="tableblock halign-left valign-top">Descripción</th>
<th class="tableblock halign-left valign-top">Valor de Ejemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">src</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">La URL de la página a incrustar.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;iframe src="https://example.com" /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">width</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Establece el ancho del iframe.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;iframe width="500" /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">height</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Establece la altura del iframe.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;iframe height="300" /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">frameborder</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Especifica si se muestra o no un borde alrededor del iframe.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;iframe frameborder="0" /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allowfullscreen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Permite que el contenido del iframe se muestre en modo de pantalla completa.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;iframe allowfullscreen /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sandbox</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Habilita un conjunto adicional de restricciones en el contenido dentro del iframe.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;iframe sandbox /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">loading</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optimiza el comportamiento de carga (por ejemplo, carga diferida).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;iframe loading="lazy" /&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">title</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Proporciona un título para el iframe para apoyar la accesibilidad.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;iframe title="Descripción" /&gt;</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<div class="title">Hay dos formas de incrustar videos en tu aplicación Next.js:</div>
<ul>
<li>
<p>Videos alojados en el propio servidor: Incrusta videos autohospedados utilizando la etiqueta &lt;video&gt; para escenarios que requieren un control detallado sobre la funcionalidad y apariencia del reproductor. Este método de integración en Next.js permite la personalización y el control de tu contenido de video.</p>
</li>
<li>
<p>Uso de servicios de alojamiento de videos (YouTube, Vimeo, etc.): Para servicios de alojamiento de videos como YouTube o Vimeo, incrustarás sus reproductores basados en iframes utilizando la etiqueta &lt;iframe&gt;. Aunque este método limita algo el control sobre el reproductor, ofrece facilidad de uso y funciones proporcionadas por estas plataformas.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fonts">Fonts</h3>
<div class="paragraph">
<p>next/font optimizará automáticamente fueentes (incluidas las fuentes personalizadas) y eliminará las solicitudes de red externas para mejorar la privacidad y el rendimiento.</p>
</div>
<div class="paragraph">
<p>next/font incluye autohospedaje automático para cualquier archivo de fuente. Esto significa que puedes cargar fuentes web de forma óptima sin ningún cambio de layout, gracias a la propiedad CSS size-adjust utilizada.</p>
</div>
<div class="paragraph">
<p>Esta nueva fuente del sistema también te permite usar convenientemente todas las fuentes de Google con el rendimiento y la privacidad en mente. Los archivos CSS y de fuentes se descargan en tiempo de compilación y se autohospedan con el resto de tus activos estáticos. No se envían solicitudes a Google por parte del navegador.</p>
</div>
<div class="sect3">
<h4 id="_google_fonts">Google Fonts</h4>
<div class="paragraph">
<p>Automáticamente autohospeda cualquier fuente de Google. Las fuentes se incluyen en el despliegue y se sirven desde el mismo dominio que tu despliegue. El navegador no envía solicitudes a Google.</p>
</div>
<div class="listingblock">
<div class="title">Comienza importando la fuente que te gustaría usar de next/font/google como una función. Recomendamos usar fuentes variables para obtener el mejor rendimiento y flexibilidad.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { Inter } from 'next/font/google'

// If loading a variable font, you don't need to specify the font weight
const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
  // weight: 400, // Optional: preload the 400 weight to avoid FOUT
  // weights: [400, 500, 600], // Optional: preload multiple weights
})

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    &lt;html lang="en" className={inter.className}&gt;
      &lt;body&gt;{children}&lt;/body&gt;
    &lt;/html&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">El primer enfoque es crear una función de utilidad que exporte una fuente, la importe y aplique su className donde sea necesario. Esto garantiza que la fuente se precargue solo cuando se renderice:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">// app/fonts.ts
import { Inter, Roboto_Mono } from 'next/font/google'

export const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
})

export const roboto_mono = Roboto_Mono({
  subsets: ['latin'],
  display: 'swap',
})

// pages/layout.tsx
import { inter } from './fonts'

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    &lt;html lang="en" className={inter.className}&gt;
      &lt;body&gt;
        &lt;div&gt;{children}&lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  )
}

// app/pages.tsx
import { roboto_mono } from './fonts'

export default function Page() {
  return (
    &lt;&gt;
      &lt;h1 className={roboto_mono.className}&gt;My page&lt;/h1&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Alternativamente, puedes crear una variable CSS y usarla con tu solución CSS preferida:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { Inter, Roboto_Mono } from 'next/font/google'
import styles from './global.css'

const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
  display: 'swap',
})

const roboto_mono = Roboto_Mono({
  subsets: ['latin'],
  variable: '--font-roboto-mono',
  display: 'swap',
})

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    &lt;html lang="en" className={`${inter.variable} ${roboto_mono.variable}`}&gt;
      &lt;body&gt;
        &lt;h1&gt;My App&lt;/h1&gt;
        &lt;div&gt;{children}&lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">En app/global.css:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-css hljs" data-lang="css">html {
  font-family: var(--font-inter);
}

h1 {
  font-family: var(--font-roboto-mono);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fuentes_personalizadas">Fuentes personalizadas</h4>
<div class="paragraph">
<p>Las fuentes personalizadas se pueden autohospedar y optimizar con next/font/local. Los archivos de fuentes se incluyen en el despliegue y se sirven desde el mismo dominio que tu despliegue. El navegador no envía solicitudes a servidores externos.</p>
</div>
<div class="listingblock">
<div class="title">Importa next/font/local y especifica la src de tu archivo de fuente local. Recomendamos usar fuentes variables para obtener el mejor rendimiento y flexibilidad.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import localFont from 'next/font/local'

// Font files can be colocated inside of `app`
const myFont = localFont({
  src: './my-font.woff2',
  display: 'swap',
})

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    &lt;html lang="en" className={myFont.className}&gt;
      &lt;body&gt;{children}&lt;/body&gt;
    &lt;/html&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Si deseas utilizar varios archivos para una sola familia de fuentes, src puede ser un array:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">const roboto = localFont({
  src: [
    {
      path: './Roboto-Regular.woff2',
      weight: '400',
      style: 'normal',
    },
    {
      path: './Roboto-Italic.woff2',
      weight: '400',
      style: 'italic',
    },
    {
      path: './Roboto-Bold.woff2',
      weight: '700',
      style: 'normal',
    },
    {
      path: './Roboto-BoldItalic.woff2',
      weight: '700',
      style: 'italic',
    },
  ],
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_metadata_2">Metadata</h3>
<div class="paragraph">
<p>Next.js tiene una API de metadatos que se puede utilizar para definir los metadatos de tu aplicación (por ejemplo, etiquetas meta y de enlace dentro del elemento head de tu HTML) para mejorar el SEO y la compartibilidad web.</p>
</div>
<div class="ulist">
<div class="title">Hay dos formas de añadir metadatos a tu aplicación:</div>
<ul>
<li>
<p><strong>Configuración basada en metadatos:</strong> Exporta un objeto de metadatos estático o una función generateMetadata dinámica en un archivo layout.js o page.js.</p>
</li>
<li>
<p><strong>Metadatos basados en archivos:</strong> Añade archivos especiales estáticos o generados dinámicamente a segmentos de ruta.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Para definir <strong>metadatos estáticos</strong>, exporta un objeto Metadata desde un archivo layout.js o page.js estático.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: '...',
  description: '...',
}

export default function Page() {}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Es posible usar la función generateMetadata para obtener metadatos que requieran valores dinámicos.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import type { Metadata, ResolvingMetadata } from 'next'

type Props = {
  params: { id: string }
  searchParams: { [key: string]: string | string[] | undefined }
}

export async function generateMetadata(
  { params, searchParams }: Props,
  parent: ResolvingMetadata
): Promise&lt;Metadata&gt; {
  // read route params
  const id = params.id

  // fetch data
  const product = await fetch(`https://.../${id}`).then((res) =&gt; res.json())

  // optionally access and extend (rather than replace) parent metadata
  const previousImages = (await parent).openGraph?.images || []

  return {
    title: product.title,
    openGraph: {
      images: ['/some-specific-page-image.jpg', ...previousImages],
    },
  }
}

export default function Page({ params, searchParams }: Props) {}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En resumen:</div>
<ul>
<li>
<p>Ambos metadatos estáticos y dinámicos a través de generateMetadata solo son compatibles en Componentes del Servidor.</p>
</li>
<li>
<p>Las solicitudes de fetch se memorizan automáticamente para los mismos datos en generateMetadata, generateStaticParams, Layouts, Pages y Componentes del Servidor. La caché de React se puede utilizar si fetch no está disponible.</p>
</li>
<li>
<p>Next.js esperará a que la obtención de datos dentro de generateMetadata se complete antes de transmitir la interfaz de usuario al cliente. Esto garantiza que la primera parte de una respuesta transmitida incluya las etiquetas &lt;head&gt;.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_optimización_de_scripts">Optimización de Scripts</h3>
<div class="paragraph">
<p>Next.js proporciona una API de optimización de scripts que te permite cargar scripts de forma diferida, asíncrona o en línea, y también te permite cargar scripts de forma condicional.</p>
</div>
<div class="listingblock">
<div class="title">Para cargar un script de terceros para múltiples rutas, importa next/script e incluye el script directamente en tu componente de layout:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Script from 'next/script'

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    &lt;&gt;
      &lt;section&gt;{children}&lt;/section&gt;
      &lt;Script src="https://example.com/script.js" /&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>El script de terceros se obtiene cuando se accede a la ruta de la carpeta (por ejemplo, dashboard/page.js) o a cualquier ruta anidada (por ejemplo, dashboard/settings/page.js) por el usuario. Next.js se asegurará de que el script se cargue solo una vez, incluso si un usuario navega entre múltiples rutas en el mismo diseño.</p>
</div>
<div class="listingblock">
<div class="title">Para cargar un script de terceros para todas las rutas, importa next/script e incluye el script directamente en tu diseño raíz:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Script from 'next/script'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;{children}&lt;/body&gt;
      &lt;Script src="https://example.com/script.js" /&gt;
    &lt;/html&gt;
  )
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_estrategias_de_carga">Estrategias de carga</h4>
<div class="paragraph">
<p>Aunque el comportamiento predeterminado de next/script te permite cargar scripts de terceros en cualquier página o diseño,</p>
</div>
<div class="ulist">
<div class="title">Es posible ajustar el comportamiento de carga de next/script utilizando la propiedad strategy:</div>
<ul>
<li>
<p><strong>beforeInteractive:</strong> Carga el script antes de cualquier código de Next.js y antes de que ocurra cualquier hidratación de página.</p>
</li>
<li>
<p><strong>afterInteractive:</strong> (predeterminado) Carga el script temprano pero después de que ocurra alguna hidratación en la página.</p>
</li>
<li>
<p><strong>lazyOnload:</strong> Carga el script más tarde durante el tiempo de inactividad del navegador.</p>
</li>
<li>
<p><strong>worker:</strong> (experimental) Carga el script en un worker web.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los scripts que utilizan la estrategia worker se descargan y ejecutan en un worker web con Partytown. Esto puede mejorar el rendimiento de tu sitio dedicando el hilo principal al resto del código de tu aplicación.</p>
</div>
<div class="listingblock">
<div class="title">Esta estrategia sigue siendo experimental y solo se puede utilizar si el indicador nextScriptWorkers está habilitado en next.config.tsx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">module.exports = {
  experimental: {
    nextScriptWorkers: true,
  },
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Los event handlers se pueden utilizar con el componente Script para ejecutar código adicional después de que ocurra un determinado evento:</div>
<ul>
<li>
<p><strong>onLoad:</strong> Ejecuta código después de que el script haya terminado de cargarse.</p>
</li>
<li>
<p><strong>onReady:</strong> Ejecuta código después de que el script haya terminado de cargarse y cada vez que se monta el componente.</p>
</li>
<li>
<p><strong>onError:</strong> Ejecuta código si el script no se carga correctamente.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Estos handlers solo funcionarán cuando next/script se importe y se utilice dentro de un Componente del Cliente donde "use client" esté definido como la primera línea de código:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import Script from 'next/script'

export default function Page() {
  return (
    &lt;&gt;
      &lt;Script
        src="https://example.com/script.js"
        onLoad={() =&gt; {
          console.log('Script has loaded')
        }}
      /&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hay muchos atributos DOM que se pueden asignar a un elemento &lt;script&gt; que no son utilizados por el componente Script, como nonce o atributos de datos personalizados. Incluir cualquier atributo adicional lo reenviará automáticamente al elemento &lt;script&gt; final y optimizado que se incluye en el HTML.</p>
</div>
<div class="listingblock">
<div class="title">Para cargar un script de forma condicional, puedes utilizar la propiedad strategy y la propiedad src:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import Script from 'next/script'

export default function Page() {
  return (
    &lt;&gt;
      &lt;Script
        src="https://example.com/script.js"
        id="example-script"
        nonce="XUENAJFW"
        data-test="script"
      /&gt;
    &lt;/&gt;
  )
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bundle_analizer">Bundle analizer</h3>
<div class="paragraph">
<p>@next/bundle-analyzer es un plugin para Next.js que te ayuda a gestionar el tamaño de tus módulos de JavaScript. Genera un informe visual del tamaño de cada módulo y sus dependencias. Puedes utilizar la información para eliminar dependencias grandes, dividir tu código o cargar solo algunas partes cuando sea necesario, reduciendo la cantidad de datos transferidos al cliente.</p>
</div>
<div class="listingblock">
<div class="title">Para instalar @next/bundle-analyzer, ejecuta el siguiente comando:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">npm i @next/bundle-analyzer
# or
yarn add @next/bundle-analyzer
# or
pnpm add @next/bundle-analyzer</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Después, añade la configuración del analizador de paquetes a tu next.config.js.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})

/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = withBundleAnalyzer(nextConfig)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para ejecutar el analizador de paquetes, añade el siguiente script a tu package.json:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "scripts": {
    "analyze": "ANALYZE=true npm run build"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>El informe se abrirá en tres nuevas pestañas en tu navegador, que puedes inspeccionar. Hacer esto regularmente mientras desarrollas y antes de desplegar tu sitio puede ayudarte a identificar grandes paquetes antes y a arquitectar tu aplicación para que sea más eficiente.</p>
</div>
</div>
<div class="sect2">
<h3 id="_lazy_loading">Lazy loading</h3>
<div class="paragraph">
<p>Lazy loading en Next.js ayuda a mejorar el rendimiento de carga inicial de una aplicación al disminuir la cantidad de JavaScript necesaria para renderizar una ruta.</p>
</div>
<div class="paragraph">
<p>Proporciona una forma de diferir la carga de Componentes del Cliente y bibliotecas importadas, e incluirlos en el paquete del cliente solo cuando sea necesario. Por ejemplo, es posible que desees diferir la carga de un modal hasta que un usuario haga clic para abrirlo.</p>
</div>
<div class="ulist">
<div class="title">Hay dos formas de implementar lazy loading en Next.js:</div>
<ul>
<li>
<p>Usando Dynamic Imports con next/dynamic</p>
</li>
<li>
<p>Usando React.lazy() con Suspense</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por defecto, los Componentes del Servidor se dividen automáticamente en código, y puedes utilizar el streaming para enviar progresivamente piezas de la interfaz de usuario del servidor al cliente. La carga diferida se aplica a los Componentes del Cliente.</p>
</div>
<div class="sect3">
<h4 id="_nextdynamic">next/dynamic</h4>
<div class="paragraph">
<p>next/dynamic es un composite de React.lazy() y Suspense. Se comporta de la misma manera en los directorios de aplicaciones y páginas para permitir una migración incremental.</p>
</div>
<div class="listingblock">
<div class="title">Para cargar un componente de forma diferida, importa next/dynamic y envuelve el componente en una llamada a la función:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { useState } from 'react'
import dynamic from 'next/dynamic'

// Client Components:
const ComponentA = dynamic(() =&gt; import('../components/A'))
const ComponentB = dynamic(() =&gt; import('../components/B'))
const ComponentC = dynamic(() =&gt; import('../components/C'), { ssr: false })

export default function ClientComponentExample() {
  const [showMore, setShowMore] = useState(false)

  return (
    &lt;div&gt;
      {/* Load immediately, but in a separate client bundle */}
      &lt;ComponentA /&gt;

      {/* Load on demand, only when/if the condition is met */}
      {showMore &amp;&amp; &lt;ComponentB /&gt;}
      &lt;button onClick={() =&gt; setShowMore(!showMore)}&gt;Toggle&lt;/button&gt;

      {/* Load only on the client side */}
      &lt;ComponentC /&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando se utiliza React.lazy() y Suspense, los Componentes del Cliente se pre-renderizarán (SSR) de forma predeterminada.</p>
</div>
<div class="listingblock">
<div class="title">Si quieres desactivar el pre-renderizado para un Componente del Cliente, puedes utilizar la opción ssr establecida en false:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">const ComponentC = dynamic(() =&gt; import('../components/C'), { ssr: false })</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si importas dinámicamente un Componente del Servidor, solo los Componentes del Cliente que sean hijos del Componente del Servidor se cargarán de forma diferida, no el Componente del Servidor en sí.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de next/dynamic en un Componente del Servidor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import dynamic from 'next/dynamic'

// Server Component:
const ServerComponent = dynamic(() =&gt; import('../components/ServerComponent'))

export default function ServerComponentExample() {
  return (
    &lt;div&gt;
      &lt;ServerComponent /&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las librerías externas se pueden cargar bajo demanda utilizando la función import(). Este ejemplo utiliza la librería externa fuse.js para la búsqueda difusa. El módulo solo se carga en el cliente después de que el usuario escriba en el campo de búsqueda.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de next/dynamic con una librería externa:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { useState } from 'react'

const names = ['Tim', 'Joe', 'Bel', 'Lee']

export default function Page() {
  const [results, setResults] = useState()

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        placeholder="Search"
        onChange={async (e) =&gt; {
          const { value } = e.currentTarget
          // Dynamically load fuse.js
          const Fuse = (await import('fuse.js')).default
          const fuse = new Fuse(names)

          setResults(fuse.search(value))
        }}
      /&gt;
      &lt;pre&gt;Results: {JSON.stringify(results, null, 2)}&lt;/pre&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de next/dynamic con un componente de carga:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import dynamic from 'next/dynamic'

const WithCustomLoading = dynamic(
  () =&gt; import('../components/WithCustomLoading'),
  {
    loading: () =&gt; &lt;p&gt;Loading...&lt;/p&gt;,
  }
)

export default function Page() {
  return (
    &lt;div&gt;
      {/* The loading component will be rendered while  &lt;WithCustomLoading/&gt; is loading */}
      &lt;WithCustomLoading /&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de next/dynamic con importaciones:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import dynamic from 'next/dynamic'

const ClientComponent = dynamic(() =&gt;
  import('../components/hello').then((mod) =&gt; mod.Hello)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_analytics">Analytics</h3>
<div class="paragraph">
<p>Next.js tiene soporte integrado para medir y reportar métricas de rendimiento. Puedes usar el gancho useReportWebVitals para gestionar el reporte tú mismo, o alternativamente, Vercel proporciona un servicio gestionado para recopilar y visualizar automáticamente las métricas por ti.</p>
</div>
<div class="sect3">
<h4 id="_métricas_propias">Métricas propias</h4>
<div class="paragraph">
<p>Para medir y reportar métricas de rendimiento, puedes utilizar el gancho useReportWebVitals. Este gancho proporciona una función de devolución de llamada que se ejecuta cada vez que se reporta una métrica de rendimiento.</p>
</div>
<div class="listingblock">
<div class="title">pp/_components/web-vitals.js:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { useReportWebVitals } from 'next/web-vitals'

export function WebVitals() {
  useReportWebVitals((metric) =&gt; {
    console.log(metric)
  })
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">app/layout.js:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { WebVitals } from './_components/web-vitals'

export default function Layout({ children }) {
  return (
    &lt;html&gt;
      &lt;body&gt;
        &lt;WebVitals /&gt;
        {children}
      &lt;/body&gt;
    &lt;/html&gt;
  )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como el hook useReportWebVitals requiere la directiva "use client", el enfoque más eficiente es crear un componente separado que importe el diseño raíz. Esto confina el límite del cliente exclusivamente al componente WebVitals.</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_vitals">Web Vitals</h4>
<div class="ulist">
<div class="title">Web Vitals son un conjunto de métricas útiles que tienen como objetivo capturar la experiencia del usuario de una página web. Las siguientes métricas web vitales están incluidas:</div>
<ul>
<li>
<p>Time to First Byte (TTFB)</p>
</li>
<li>
<p>First Contentful Paint (FCP)</p>
</li>
<li>
<p>Largest Contentful Paint (LCP)</p>
</li>
<li>
<p>First Input Delay (FID)</p>
</li>
<li>
<p>Cumulative Layout Shift (CLS)</p>
</li>
<li>
<p>Interaction to Next Paint (INP)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Es posible manejar todos los resultados de estas métricas utilizando la propiedad name.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { useReportWebVitals } from 'next/web-vitals'

export function WebVitals() {
  useReportWebVitals((metric) =&gt; {
    switch (metric.name) {
      case 'FCP': {
        // handle FCP results
      }
      case 'LCP': {
        // handle LCP results
      }
      // ...
    }
  })
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Es posible enviar los resultados a cualquier punto final para medir y rastrear el rendimiento real del usuario en tu sitio. Por ejemplo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">useReportWebVitals((metric) =&gt; {
  const body = JSON.stringify(metric)
  const url = 'https://example.com/analytics'

  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
  if (navigator.sendBeacon) {
    navigator.sendBeacon(url, body)
  } else {
    fetch(url, { body, method: 'POST', keepalive: true })
  }
})</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_librerías_de_terceros">Librerías de terceros</h3>
<div class="paragraph">
<p>@next/third-parties es una librería que proporciona una colección de componentes y utilidades que mejoran el rendimiento y la experiencia del desarrollador al cargar bibliotecas de terceros populares en tu aplicación Next.js.</p>
</div>
<div class="paragraph">
<p>@next/third-parties es actualmente una librería experimental en desarrollo activo. Recomendamos instalarla con las banderas latest o canary mientras trabajamos en añadir más integraciones de terceros.</p>
</div>
<div class="listingblock">
<div class="title">Para instalar @next/third-parties, ejecuta el siguiente comando:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">npm install @next/third-parties@latest next@latest</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_google_tag_manager">Google Tag Manager</h4>
<div class="paragraph">
<p>El componente GoogleTagManager se puede utilizar para instanciar un contenedor de Google Tag Manager en una aplicación. De forma predeterminada, obtiene el script en línea original después de que se haya producido la hidratación en la página.</p>
</div>
<div class="listingblock">
<div class="title">Para cargar Google Tag Manager para todas las rutas, incluye el componente directamente en tu diseño raíz y pasa tu ID de contenedor GTM:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { GoogleTagManager } from '@next/third-parties/google'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    &lt;html lang="en"&gt;
      &lt;GoogleTagManager gtmId="GTM-XYZ" /&gt;
      &lt;body&gt;{children}&lt;/body&gt;
    &lt;/html&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para cargar Google Tag Manager para una sola ruta, incluye el componente en tu archivo de página:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { GoogleTagManager } from '@next/third-parties/google'

export default function Page() {
  return &lt;GoogleTagManager gtmId="GTM-XYZ" /&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función sendGTMEvent se puede utilizar para rastrear las interacciones del usuario en tu página enviando eventos utilizando el objeto dataLayer. Para que esta función funcione, el componente &lt;GoogleTagManager /&gt; debe incluirse en un diseño principal, página o componente, o directamente en el mismo archivo.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de sendGTMEvent:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { sendGTMEvent } from '@next/third-parties/google'

export function EventButton() {
  return (
    &lt;div&gt;
      &lt;button
        onClick={() =&gt; sendGTMEvent({ event: 'buttonClicked', value: 'xyz' })}
      &gt;
        Send Event
      &lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 12. Opciones para pasar a Google Tag Manager. Para obtener una lista completa de opciones, lee la documentación de Google Tag Manager.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Nombre</th>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">gtmId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requerido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tu ID de contenedor de GTM. Generalmente comienza con GTM-.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dataLayer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Matriz de capa de datos para iniciar el contenedor. Por defecto es un array vacío.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dataLayerName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nombre de la capa de datos. Por defecto es dataLayer.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">auth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Valor del parámetro de autenticación (gtm_auth) para fragmentos de entorno.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">preview</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Valor del parámetro de vista previa (gtm_preview) para fragmentos de entorno.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_google_analytics">Google Analytics</h4>
<div class="paragraph">
<p>El componente GoogleAnalytics se puede utilizar para incluir Google Analytics 4 en tu aplicación a través de la etiqueta de Google (gtag.js). De forma predeterminada, obtiene los scripts originales después de que se haya producido la hidratación en la página.</p>
</div>
<div class="paragraph">
<p>Si Google Tag Manager ya está incluido en tu aplicación, puedes configurar Google Analytics directamente utilizando Tag Manager, en lugar de incluir Google Analytics como un componente separado. Consulta la documentación para obtener más información sobre las diferencias entre Tag Manager y gtag.js.</p>
</div>
<div class="listingblock">
<div class="title">Para cargar Google Analytics para todas las rutas, incluye el componente directamente en tu diseño raíz y pasa tu ID de medición:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { GoogleAnalytics } from '@next/third-parties/google'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;{children}&lt;/body&gt;
      &lt;GoogleAnalytics gaId="G-XYZ" /&gt;
    &lt;/html&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para cargar Google Analytics para una sola ruta, incluye el componente en tu archivo de página:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { GoogleAnalytics } from '@next/third-parties/google'

export default function Page() {
  return &lt;GoogleAnalytics gaId="G-XYZ" /&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La función sendGAEvent se puede utilizar para medir las interacciones del usuario en tu página enviando eventos utilizando el objeto dataLayer. Para que esta función funcione, el componente &lt;GoogleAnalytics /&gt; debe incluirse en un diseño principal, página o componente, o directamente en el mismo archivo.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de sendGAEvent:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use client'

import { sendGAEvent } from '@next/third-parties/google'

export function EventButton() {
  return (
    &lt;div&gt;
      &lt;button
        onClick={() =&gt; sendGAEvent({ event: 'buttonClicked', value: 'xyz' })}
      &gt;
        Send Event
      &lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 13. Opciones para pasar a Google Analytics.</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Nombre</th>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">gaId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requerido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tu ID de medición. Generalmente comienza con G-.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dataLayerName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nombre de la capa de datos. Por defecto es dataLayer.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_google_maps_embed">Google Maps Embed</h4>
<div class="paragraph">
<p>El componente GoogleMapsEmbed se puede utilizar para añadir un Google Maps Embed a tu página. De forma predeterminada, utiliza el atributo de carga para cargar de forma diferida el embed debajo del pliegue.</p>
</div>
<div class="listingblock">
<div class="title">Para cargar Google Maps Embed para todas las rutas, incluye el componente directamente el componente:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { GoogleMapsEmbed } from '@next/third-parties/google'

export default function Page() {
  return (
    &lt;GoogleMapsEmbed
      apiKey="XYZ"
      height={200}
      width="100%"
      mode="place"
      q="Brooklyn+Bridge,New+York,NY"
    /&gt;
  )
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 14. Las opciones para pasar a Google Maps Embed son:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Nombre</th>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">apiKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requerido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tu clave de API.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requerido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Modo del mapa.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">height</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Altura de la incrustación. Por defecto es auto.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">width</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ancho de la incrustación. Por defecto es auto.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">style</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pasar estilos al iframe.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allowfullscreen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Propiedad para permitir que ciertas partes del mapa se vean en pantalla completa.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">loading</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Por defecto es lazy. Considera cambiarlo si sabes que tu incrustación estará visible inmediatamente.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">q</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Define la ubicación del marcador del mapa. Esto puede ser requerido dependiendo del modo del mapa.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">center</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Define el centro de la vista del mapa.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">zoom</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Establece el nivel de zoom inicial del mapa.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maptype</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Define el tipo de mosaicos de mapa a cargar.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">language</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Define el idioma a usar para los elementos de la interfaz y para la visualización de etiquetas en los mosaicos del mapa.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">region</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Define las fronteras y etiquetas apropiadas a mostrar, basadas en sensibilidades geopolíticas.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_youtube_embed">Youtube Embed</h4>
<div class="paragraph">
<p>El componente YouTubeEmbed se puede utilizar para cargar y mostrar un embed de YouTube. Este componente carga más rápido utilizando lite-youtube-embed bajo el capó.</p>
</div>
<div class="listingblock">
<div class="title">Un ejemplo de uso de YouTubeEmbed:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { YouTubeEmbed } from '@next/third-parties/google'

export default function Page() {
  return &lt;YouTubeEmbed videoid="ogfYd705cRs" height={400} params="controls=0" /&gt;
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 15. Las opciones para pasar a YouTubeEmbed son:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Nombre</th>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">videoid</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requerido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID del video de YouTube.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">width</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ancho del contenedor del video. Por defecto es auto.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">height</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Altura del contenedor del video. Por defecto es auto.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">playlabel</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Una etiqueta visualmente oculta para el botón de reproducción para accesibilidad.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">params</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Los parámetros del reproductor de video definidos aquí. Los parámetros se pasan como una cadena de consulta. Ejemplo: params="controls=0&amp;start=10&amp;end=30"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">style</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Utilizado para aplicar estilos al contenedor del video.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_autenticación">Autenticación</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Next.js proporciona una API de autenticación que te permite autenticar a los usuarios en tu aplicación. Puedes utilizar esta API para implementar la autenticación de usuarios, la autorización de rutas y la gestión de sesiones.</p>
</div>
<div class="ulist">
<div class="title">Para implementar la autenticación en Next.js, familiarízate con tres conceptos fundamentales:</div>
<ul>
<li>
<p><strong>Autenticación</strong> verifica si el usuario es quien dice ser. Requiere que el usuario demuestre su identidad con algo que tiene, como un nombre de usuario y una contraseña.</p>
</li>
<li>
<p><strong>Gestión de Sesión</strong> rastrea el estado del usuario (por ejemplo, conectado) a través de múltiples solicitudes.</p>
</li>
<li>
<p><strong>Autorización</strong> decide a qué partes de la aplicación tiene acceso el usuario.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_autenticación_2">Autenticación</h3>
<div class="paragraph">
<p>La autenticación verifica la identidad de un usuario. Esto sucede cuando un usuario inicia sesión, ya sea con un nombre de usuario y una contraseña o a través de un servicio como Google. Se trata de confirmar que los usuarios son realmente quienes dicen ser, protegiendo tanto los datos del usuario como la aplicación de accesos no autorizados o actividades fraudulentas.</p>
</div>
<div class="ulist">
<div class="title">Estrategias de Autenticación en aplicaciones web modernas:</div>
<ul>
<li>
<p><strong>OAuth/OpenID Connect:</strong> Permite el acceso de terceros sin compartir credenciales de usuario. Ideal para iniciar sesión en redes sociales y soluciones de inicio de sesión único (SSO). Agregan una capa de identidad con OpenID Connect.</p>
</li>
<li>
<p><strong>Credenciales basadas en el inicio de sesión (Email + Contraseña):</strong> Una elección estándar para aplicaciones web, donde los usuarios inician sesión con un correo electrónico y una contraseña. Familiar y fácil de implementar, requiere medidas de seguridad sólidas contra amenazas como el phishing.</p>
</li>
<li>
<p><strong>Autenticación sin contraseña/basada en tokens:</strong> Utiliza enlaces mágicos de correo electrónico o códigos de un solo uso de SMS para un acceso seguro sin contraseña. Popular por su conveniencia y seguridad mejorada, este método ayuda a reducir la fatiga de contraseñas. Su limitación es la dependencia de la disponibilidad de correo electrónico o teléfono del usuario.</p>
</li>
<li>
<p><strong>Passkeys/WebAuthn:</strong> Utiliza credenciales criptográficas únicas para cada sitio, ofreciendo una alta seguridad contra el phishing. Seguro pero nuevo, esta estrategia puede ser difícil de implementar.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">El proceso de autenticación convencional sigue estos pasos:</div>
<ul>
<li>
<p>El usuario envía sus credenciales a través de un formulario de inicio de sesión.</p>
</li>
<li>
<p>El formulario llama a una acción del servidor.</p>
</li>
<li>
<p>Si la verificación es exitosa, el proceso se completa, indicando la autenticación exitosa del usuario.</p>
</li>
<li>
<p>Si la verificación no tiene éxito, se muestra un mensaje de error.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">El formulario de inicio de sesión es un componente React que recopila las credenciales del usuario y las envía al servidor para su verificación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { authenticate } from '@/app/lib/actions'

export default function Page() {
  return (
    &lt;form action={authenticate}&gt;
      &lt;input type="email" name="email" placeholder="Email" required /&gt;
      &lt;input type="password" name="password" placeholder="Password" required /&gt;
      &lt;button type="submit"&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Usamos una función de autenticación en una Server Action para demostrar el proceso de autenticación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use server'

 // signIn es una función de autenticación que verifica las credenciales del usuario
import { signIn } from '@/auth'

export async function authenticate(_currentState: unknown, formData: FormData) {
  try {
    await signIn('credentials', formData)
  } catch (error) {
    if (error) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Invalid credentials.'
        default:
          return 'Something went wrong.'
      }
    }
    throw error
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_autorización">Autorización</h3>
<div class="paragraph">
<p>La autorización decide qué partes de la aplicación tiene acceso un usuario. Se trata de controlar qué recursos y acciones están disponibles para un usuario autenticado. La autorización se basa en la identidad del usuario y en los roles y permisos asociados.</p>
</div>
<div class="paragraph">
<p>En Next.js tenemos los Middleware para gestionar la autorización de rutas de forma sencilla.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Middleware de Ruta:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const currentUser = request.cookies.get('currentUser')?.value

  if (currentUser &amp;&amp; !request.nextUrl.pathname.startsWith('/dashboard')) {
    return Response.redirect(new URL('/dashboard', request.url))
  }

  if (!currentUser &amp;&amp; !request.nextUrl.pathname.startsWith('/login')) {
    return Response.redirect(new URL('/login', request.url))
  }
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Es necesario tratar las Server Actions con las mismas consideraciones de seguridad que los endpoints de una API. Hay que implementar comprobaciones dentro de las Server Actions para determinar los permisos de usuario.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Server Action con Autorización:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use server'

// ...

export async function serverAction() {
  const session = await getSession()
  const userRole = session?.user?.role

  // Check if user is authorized to perform the action
  if (userRole !== 'admin') {
    throw new Error('Unauthorized access: User does not have admin privileges.')
  }

  // Proceed with the action for authorized users
  // ... implementation of the action
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los Route Handlers en Next.js desempeñan tareas en la gestión de las solicitudes entrantes. Al igual que las Server Actions, deben estar aseguradas para garantizar que solo los usuarios autorizados puedan acceder a ciertas funcionalidades. Esto a menudo implica verificar el estado de autenticación del usuario y sus permisos.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Route Handler con Autorización:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export async function GET() {
  // User authentication and role verification
  const session = await getSession()

  // Check if the user is authenticated
  if (!session) {
    return new Response(null, { status: 401 }) // User is not authenticated
  }

  // Check if the user has the 'admin' role
  if (session.user.role !== 'admin') {
    return new Response(null, { status: 403 }) // User is authenticated but does not have the right permissions
  }

  // Data fetching for authorized users
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los Server Components permiten a los desarrolladores controlar la lógica de autorización en el servidor, lo que garantiza que los datos sensibles no se envíen a los Client Components.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Server Component con Autorización:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">export default async function Dashboard() {
  const session = await getSession()
  const userRole = session?.user?.role // Assuming 'role' is part of the session object

  if (userRole === 'admin') {
    return &lt;AdminDashboard /&gt; // Component for admin users
  } else if (userRole === 'user') {
    return &lt;UserDashboard /&gt; // Component for regular users
  } else {
    return &lt;AccessDenied /&gt; // Component shown for unauthorized access
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Mejores Prácticas</div>
<ul>
<li>
<p><strong>Securiza la gestión de sesiones:</strong> Prioriza la seguridad de los datos de sesión para evitar el acceso no autorizado y las violaciones de datos. Utiliza prácticas de cifrado y almacenamiento seguro.</p>
</li>
<li>
<p><strong>Gestión dinámica de roles:</strong> Utiliza un sistema flexible para los roles de usuario para ajustarte fácilmente a los cambios en los permisos y roles, evitando roles codificados.</p>
</li>
<li>
<p><strong>Enfoque de seguridad primero:</strong> En todos los aspectos de la lógica de autorización, prioriza la seguridad para proteger los datos de los usuarios y mantener la integridad de tu aplicación. Esto incluye pruebas exhaustivas y considerar posibles vulnerabilidades de seguridad.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_de_sesiones">Gestión de Sesiones</h3>
<div class="paragraph">
<p>La gestión de sesiones implica el seguimiento y la gestión de la interacción de un usuario con la aplicación a lo largo del tiempo, garantizando que su estado autenticado se preserve en diferentes partes de la aplicación.</p>
</div>
<div class="sect3">
<h4 id="_sesiones_basadas_en_cookies">Sesiones basadas en cookies</h4>
<div class="paragraph">
<p>Las sesiones basadas en cookies son una forma común de gestionar la autenticación y la autorización en aplicaciones web modernas. Almacenan información de sesión cifrada directamente en las cookies del navegador, lo que permite a los usuarios mantener su estado autenticado en diferentes partes de la aplicación.</p>
</div>
<div class="listingblock">
<div class="title">Configurar una cookie en un Server Component:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">'use server'

import { cookies } from 'next/headers'

export async function handleLogin(sessionData) {
  const encryptedSessionData = encrypt(sessionData) // Encrypt your session data
  cookies().set('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // One week
    path: '/',
  })
  // Redirect or handle the response after setting the cookie
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">La función getSession en un Server Component:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { cookies } from 'next/headers'

export async function getSessionData(req) {
  const encryptedSessionData = cookies().get('session')?.value
  return encryptedSessionData ? JSON.parse(decrypt(encryptedSessionData)) : null
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_sesiones_en_bases_de_datos">Gestión de Sesiones en bases de datos</h4>
<div class="paragraph">
<p>La gestión de sesiones en bases de datos implica almacenar los datos de sesión en el servidor, con el navegador del usuario recibiendo solo un ID de sesión. Este ID hace referencia a los datos de sesión almacenados en el servidor, sin contener los datos en sí. Este método mejora la seguridad, ya que mantiene los datos de sesión sensibles alejados del entorno del lado del cliente, reduciendo el riesgo de exposición a ataques del lado del cliente. Las sesiones de base de datos también son más escalables, ya que pueden acomodar necesidades de almacenamiento de datos más grandes.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de gestión de sesiones en bases de datos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import db from './lib/db'

export async function createSession(user) {
  const sessionId = generateSessionId() // Generate a unique session ID
  await db.insertSession({ sessionId, userId: user.id, createdAt: new Date() })
  return sessionId
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para obtener una sesión en un Middleware o en la lógica del lado del servidor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsx hljs" data-lang="jsx">import { cookies } from 'next/headers'
import db from './lib/db'

export async function getSession() {
  const sessionId = cookies().get('sessionId')?.value
  return sessionId ? await db.findSession(sessionId) : null
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_librerías_de_autenticación">Librerías de Autenticación</h4>
<div class="paragraph">
<p>Con las soluciones de autenticación como NextAuth.js, la gestión de sesiones se vuelve más eficiente, utilizando cookies o almacenamiento en base de datos. Esta automatización simplifica el proceso de desarrollo, pero es importante entender el método de gestión de sesiones utilizado por la solución elegida. Asegúrate de que se alinee con los requisitos de seguridad y rendimiento de tu aplicación.</p>
</div>
<div class="ulist">
<div class="title">Aquí hay una lista de soluciones de autenticación compatibles con Next.js:</div>
<ul>
<li>
<p><a href="https://authjs.dev/getting-started/migrating-to-v5">NextAuth.js</a></p>
</li>
<li>
<p><a href="https://auth0.com/docs/quickstart/webapp/nextjs/01-login">Auth0</a></p>
</li>
<li>
<p><a href="https://clerk.com/docs/quickstarts/nextjs">Clerk</a></p>
</li>
<li>
<p><a href="https://docs.kinde.com/developer-tools/sdks/backend/nextjs-sdk/">Kinde</a></p>
</li>
<li>
<p><a href="https://lucia-auth.com/getting-started/nextjs-app">Lucia</a></p>
</li>
<li>
<p><a href="https://supabase.com/docs/guides/getting-started/quickstarts/nextjs">Supabase</a></p>
</li>
<li>
<p><a href="https://stytch.com/docs/guides/quickstarts/nextjs">Stytch</a></p>
</li>
<li>
<p><a href="https://github.com/vvo/iron-session">Iron Session</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-07-04 07:15:14 +0200
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>