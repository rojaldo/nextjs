:source-highlighter: highlight.js
= Jest 

== Introducción 

Jest es un framework de pruebas de JavaScript creado por Facebook. Es fácil de usar y se integra perfectamente con proyectos de React.

== Instalación

Para instalar Jest, primero debes tener Node.js instalado en tu proyecto.

.Puedes instalar Jest usando npm:
```bash	
npm install --save-dev jest
```

.Para configurar Jest en tu proyecto, debes agregar un script en tu archivo `package.json`:
```json
"scripts": {
  "test": "jest"
}
```

.El archivo de configuración de Jest debe llamarse `jest.config.js` y debe estar en la raíz de tu proyecto:
```javascript
module.exports = {
  testEnvironment: 'node',
};
```

== Crear pruebas

Para crear una prueba, debes crear un archivo con la extensión `.test.ts` o `.spec.ts`. Por ejemplo, `sum.test.ts`:

.Un ejemplo de prueba: 
```typescript
function sum(a: number, b: number): number {
  return a + b;
}

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```

== Matchers

Los matchers son funciones que te permiten comprobar si un valor cumple con ciertas condiciones. 

.Los matchers más comunes son:
* `toBe(value)`: Comprueba si el valor es igual a `value`.
* `toEqual(value)`: Comprueba si el valor es igual a `value` recursivamente.
* `toBeTruthy()`: Comprueba si el valor es verdadero.
* `toBeFalsy()`: Comprueba si el valor es falso.
* `toBeNull()`: Comprueba si el valor es nulo.
* `toBeUndefined()`: Comprueba si el valor es indefinido.
* `toBeDefined()`: Comprueba si el valor está definido.
* `toContain(value)`: Comprueba si el valor contiene `value`. Siendo `value` un array o un string.
* `toHaveLength(length)`: Comprueba si el valor tiene la longitud `length`.
* `toBeGreaterThan(value)`: Comprueba si el valor es mayor que `value`.
* `toBeLessThan(value)`: Comprueba si el valor es menor que `value`.
* `toBeCloseTo(value, precision)`: Comprueba si el valor es cercano a `value` con una precisión de `precision`.
* `toThrow()`: Comprueba si el valor lanza una excepción.
* `toMatch(regexp)`: Comprueba si el valor coincide con la expresión regular `regexp`.
* `toBeInstanceOf(class)`: Comprueba si el valor es una instancia de la clase `class`.
* `toHaveProperty(keyPath, value)`: Comprueba si el valor tiene la propiedad `keyPath` con el valor `value`.

.Combinaciones con expect:
```typescript
`expect(value).not.toBe(value)`: Comprueba si el valor no es igual a `value`.
`expect(() => compileAndroidCode()).toThrow();
`expect(() => compileAndroidCode()).toThrow(Error);
`expect(() => compileAndroidCode()).toThrow('You are using the wrong JDK');`
```

== Estructura de testing en Jest

.Para organizar tus pruebas, puedes agruparlas en bloques usando las funciones `describe` y `it`:
```typescript
describe('sum', () => {
  it('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});
```

El bloque `describe` agrupa las pruebas y el bloque `it` define una prueba.
Cada bloque `describe` puede contener varios bloques `it` y otros bloques `describe`.

.Además de los bloques `describe` y `it`, Jest proporciona las funciones:
* `beforeAll(fn)`: Se ejecuta una vez antes de todas las pruebas.
* `beforeEach(fn)`: Se ejecuta antes de cada prueba.
* `afterEach(fn)`: Se ejecuta después de cada prueba.
* `afterAll(fn)`: Se ejecuta una vez después de todas las pruebas.

.Un ejemplo de estructura de testing:
```typescript
describe('sum', () => {
  let a: number;
  let b: number;

  beforeAll(() => {
    a = 1;
    b = 2;
  });

  beforeEach(() => {
    console.log('before each');
  });

  afterEach(() => {
    console.log('after each');
  });

  afterAll(() => {
    console.log('after all');
  });

  it('adds 1 + 2 to equal 3', () => {
    expect(sum(a, b)).toBe(3);
  });

  it('adds 2 + 3 to equal 5', () => {
    expect(sum(2, 3)).toBe(5);
  });
});
```

.El código anterior se ejecutará de la siguiente manera:
* `beforeAll` se ejecuta una vez antes de todas las pruebas.
* `beforeEach` se ejecuta antes de cada prueba.
* `it` ejecuta la primera prueba.
* `afterEach` se ejecuta después de cada prueba.
* `beforeEach` se ejecuta antes de la segunda prueba.
* `it` ejecuta la segunda prueba.
* `afterEach` se ejecuta después de cada prueba.
* `afterAll` se ejecuta una vez después de todas las pruebas.

== Testing con código asincrónico

.Para probar código asincrónico, Jest proporciona dos formas de hacerlo: 
* callbacks 
* promesas.
* resolves/rejects

.Para probar código asincrónico con callbacks, debes usar la función `done`:
```typescript
function fetchData(callback: (data: string) => void) {
  setTimeout(() => {
    callback('pepe');
  }, 1000);
}

test('the data is pepe', (done) => {
  function callback(data: string) {
    expect(data).toBe('pepe');
    done();
  }

  fetchData(callback);
});
```

.Para probar código asincrónico con promesas, debes usar la palabra clave `async` y la función `await`:
```typescript
function fetchData(): Promise<string> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('pepe');
    }, 1000);
  });
}

test('the data is pepe', async () => {
  const data = await fetchData();
  expect(data).toBe('pepe');
});
```
.Para probar código asincrónico con promesas, también puedes usar `resolves` y `rejects`:
```typescript
function fetchData(): Promise<string> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('pepe');
    }, 1000);
  });
}

test('the data is pepe', () => {
  return expect(fetchData()).resolves.toBe('pepe');
});

test('the fetch fails with an error', () => {
  return expect(fetchData()).rejects.toThrow('error');
});
```
== Mocking

Las pruebas unitarias deben probar una función de forma aislada, sin depender de otras funciones o servicios. Para lograr esto, puedes usar mocks para simular el comportamiento de una función o servicio.

.Para mockear una función, debes usar la función `jest.fn()`:
```typescript
function fetchData(callback: (data: string) => void) {
  setTimeout(() => {
    callback('pepe');
  }, 1000);
}

test('the data is pepe', () => {
  const callback = jest.fn();
  fetchData(callback);

  expect(callback).toHaveBeenCalledWith('pepe');
});
```

.Los métodos más comunes de un mock son:
* `mock.calls`: Un array que contiene los argumentos de cada llamada.
* `mock.results`: Un array que contiene los resultados de cada llamada.
* `mock.calls[0][0]`: El primer argumento de la primera llamada.
* `mock.results[0].value`: El valor de retorno de la primera llamada.

Todas las funciones de mock tienen esta propiedad especial .mock, que es donde se guarda la información sobre cómo se ha llamado la función y qué ha devuelto la función. La propiedad .mock también realiza un seguimiento del valor de this para cada llamada, por lo que es posible inspeccionar esto también.

.Ejemplo de uso de mocks:
```typescript
const myMock1 = jest.fn();
const a = new myMock1();
console.log(myMock1.mock.instances);
// > [ <a> ]

const myMock2 = jest.fn();
const b = {};
const bound = myMock2.bind(b);
bound();
console.log(myMock2.mock.contexts);
// > [ <b> ]
```

.Estos miembros de mock son muy útiles en las pruebas para afirmar cómo se llaman estas funciones, se instancian o qué devuelven:
```typescript
// The function was called exactly once
expect(someMockFunction.mock.calls).toHaveLength(1);

// The first arg of the first call to the function was 'first arg'
expect(someMockFunction.mock.calls[0][0]).toBe('first arg');

// The second arg of the first call to the function was 'second arg'
expect(someMockFunction.mock.calls[0][1]).toBe('second arg');

// The return value of the first call to the function was 'return value'
expect(someMockFunction.mock.results[0].value).toBe('return value');

// The function was called with a certain `this` context: the `element` object.
expect(someMockFunction.mock.contexts[0]).toBe(element);

// This function was instantiated exactly twice
expect(someMockFunction.mock.instances.length).toBe(2);

// The object returned by the first instantiation of this function
// had a `name` property whose value was set to 'test'
expect(someMockFunction.mock.instances[0].name).toBe('test');

// The first argument of the last call to the function was 'test'
expect(someMockFunction.mock.lastCall[0]).toBe('test');
```

.Return mock values:
```typescript
const myMock = jest.fn();
console.log(myMock());
// > undefined

myMock.mockReturnValueOnce(10).mockReturnValueOnce('x').mockReturnValue(true);

console.log(myMock(), myMock(), myMock(), myMock());
// > 10, 'x', true, true
```

.Mocking de módulos:
```typescript
// user.ts
import axios from 'axios';

class Users {
  static all() {
    return axios.get('/users.json').then(resp => resp.data);
  }
}

export default Users;

// user.test.ts

import axios from 'axios';
import Users from './users';

jest.mock('axios');

test('should fetch users', () => {
  const users = [{name: 'Bob'}];
  const resp = {data: users};
  axios.get.mockResolvedValue(resp);

  // or you could use the following depending on your use case:
  // axios.get.mockImplementation(() => Promise.resolve(resp))

  return Users.all().then(data => expect(data).toEqual(users));
});
```
